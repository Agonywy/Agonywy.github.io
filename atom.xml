<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>如你所是</title>
  
  <subtitle>Agonywy</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://agonywy.github.io/"/>
  <updated>2020-08-16T10:07:30.000Z</updated>
  <id>https://agonywy.github.io/</id>
  
  <author>
    <name>Agonywy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>席卷Java各种锁</title>
    <link href="https://agonywy.github.io/2020/07/21/%E5%B8%AD%E5%8D%B7Java%E4%B8%BB%E6%B5%81%E9%94%81/"/>
    <id>https://agonywy.github.io/2020/07/21/%E5%B8%AD%E5%8D%B7Java%E4%B8%BB%E6%B5%81%E9%94%81/</id>
    <published>2020-07-21T13:42:35.000Z</published>
    <updated>2020-08-16T10:07:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java主流锁"><a href="#Java主流锁" class="headerlink" title="Java主流锁"></a>Java主流锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">乐观锁，悲观锁</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">读锁(共享锁)，写锁(排他锁)</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">自旋锁,非自旋锁</span></span><br><span class="line"><span class="attr">4</span>:<span class="string">无锁--&gt;偏向锁--&gt;轻量级锁--&gt;重量级锁(JVM内置锁的膨胀升级过程)</span></span><br><span class="line"><span class="attr">5</span>:<span class="string">分布式锁</span></span><br><span class="line"><span class="attr">6</span>:<span class="string">区间锁(分段锁),在ConcurrentHashMap中有所体现,JUC下面的类基本都有体现</span></span><br><span class="line"><span class="attr">7</span>:<span class="string">重入锁,非重入锁</span></span><br><span class="line"><span class="attr">8</span>:<span class="string">公平锁，非公平锁</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">悲观锁</span>:<span class="string">悲观锁认为自己在使用数据的时候一定会有别的线程来修改数据,在获取数据的时候会先加锁,确保数据不会被其他线程修改</span></span><br><span class="line"><span class="meta">锁实现</span>:<span class="string">关键字Synchronized,接口Lock的实现类</span></span><br><span class="line"><span class="meta">乐观锁</span>:<span class="string">乐观锁认为自己在使用数据的时候不会有别的线程修改数据,所以不会添加锁,只是在更新数据的时候去判断之前有没有线程更新了这个数据</span></span><br><span class="line"><span class="meta">锁实现</span>:<span class="string">CAS算法,ActotomicInteger类的原子自增就是通过CAS自旋实现的</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#悲观锁执行过程:</span></span><br><span class="line"><span class="attr">线程1和线程2去获取共享资源,线程1拿到锁去操作资源,线程2就会阻塞,等线程1执行完毕之后,释放锁,线程2才能再去获取锁操作共享资源</span></span><br><span class="line"><span class="comment">#乐观锁的执行过程</span></span><br><span class="line"><span class="attr">线程在获取到共享资源准备修改的时候,需要先判断内存中的数据有没有被修改,如果没有,那么就可以执行修改操作,如果被修改了,就要重现获取数据执行操作,然后重复CAS直到成功</span></span><br></pre></td></tr></table></figure><h4 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CAS</span>:<span class="string">Compare and Swap:涉及到三个操作数,V是需要读写的内存值(堆内存),A进行比较的值,维护在栈内存中的一个副本,B是我们的更新值,只有当V=A的时候,我们才可以使用B去修改V(只有当栈中副本值与主内存的value值相等的时候,我们才能使用更新值B去更新主内存中的value)</span></span><br><span class="line"><span class="meta">CAS自旋的过程</span>:<span class="string">重新load内存中的值到栈中,重新进行更新操作,再一次进行compare and swap操作</span></span><br><span class="line"><span class="meta">特点</span>:<span class="string">CAS不放弃CPU时间片,通过自旋等待获取锁</span></span><br></pre></td></tr></table></figure><h4 id="CAS在Atomic中的实现"><a href="#CAS在Atomic中的实现" class="headerlink" title="CAS在Atomic中的实现"></a>CAS在Atomic中的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSetInt</span><span class="params">(Object var1, Long var2, <span class="keyword">int</span> var4)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1,var2);</span><br><span class="line">    &#125;<span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1,var2,var5,var4));</span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CAS存在的问题"><a href="#CAS存在的问题" class="headerlink" title="CAS存在的问题"></a>CAS存在的问题</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(1)ABA问题</span>:<span class="string">线程1读书到内存值A之后,准备要去修改内存值,这时候线程2将内存中的值从A修改成了B,之后内存值又被其他线程从B修改成了A,这个时候当线程1准备修改内存值的时候,CAS发现内存值没有改变,这个时候CAS成功了,但是这个时候内存中的值已经不是最初的状态了,因此发生了错误</span></span><br><span class="line"><span class="meta">解决方案</span>:<span class="string">在变量上面加上版本号,Atomic中为我们提供了一个AtomicStampReference类来做版本标记,我们CAS的时候不仅要比较你栈内存中的副本和主内存中的值是否相同,还要判断版本号是否相同,只有都满足的时候才能保证内存中的值没有被修改,CAS才能够成功,否则CAS会失败</span></span><br><span class="line"><span class="meta">(2)循环时间开销大</span>:<span class="string">如果CAS操作一直失败,就需要循环进行CAS操作,这种方式也称为自选如果一直不成功的话就会很耗费系统资源</span></span><br><span class="line"><span class="meta">解决方案</span>:<span class="string">限制自旋次数,防止陷入死循环</span></span><br><span class="line"><span class="meta">(3)只能保证一个共享变量的原子操作</span>:<span class="string">CAS的原子操作只能针对一个共享变量</span></span><br><span class="line"><span class="meta">解决方案</span>:<span class="string">如果要对多个共享变量进行操作,需要使用加锁的方式保证原子性</span></span><br></pre></td></tr></table></figure><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">自旋锁</span>:<span class="string">是指当一个线程在获取锁的时候,如果该锁已经被其他线程获取了,那么该线程会循环等待,然后不断的判断锁是否能够获取,自旋直到成功获取到锁后,才会退出循环</span></span><br><span class="line"><span class="meta">自适应自旋锁</span>:<span class="string">自适应自旋假定不同线程持有同一个锁对象的时间基本相当,竞争程度趋于稳定,因此可以根据上一次自旋的时间与结果调整下一次自旋的时间</span></span><br></pre></td></tr></table></figure><p><strong>自旋锁存在的意义和使用场景</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">(1)</span>:<span class="string">阻塞与欢迎需要操作系统切换CUP状态,需要消耗一定的时间</span></span><br><span class="line"><span class="meta">(2)</span>:<span class="string">同步代码快逻辑简单,执行时间很短的时候自旋锁效率更高,因为自旋不放弃CPU时间片CPU切换上下文很消耗资源,所以自旋反而效率高</span></span><br><span class="line"><span class="meta">上下文切换</span>:<span class="string">JVM运行在操作系统上,JVM是用户态,操作系统是核心态,真正的调度对硬件的操作只有操作系统才有这样的权限,JVM要通知CPU进行上下文的切换,无法直接向CPU发出指令,所以只能借助操作系统去通知CPU进行上下文切换,因此这里就涉及到用户态与内核态之间的切换,比如线程1执行到一半上下文切换,他的变量都暂时存放在了进程中的PCB(进程控制块)中,当线程1恢复执行的时候,CPU又得从PCB中重新读取线程1的变量去执行操作,这个过程就很耗费资源</span></span><br></pre></td></tr></table></figure><h4 id="Synchronized分析"><a href="#Synchronized分析" class="headerlink" title="Synchronized分析"></a>Synchronized分析</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">synchronized使用方式</span>:<span class="string"></span></span><br><span class="line"><span class="meta">(1)</span>:<span class="string">同步实例方法,锁是当前实例对象</span></span><br><span class="line"><span class="meta">(2)</span>:<span class="string">同步类方法,锁是当前类对象</span></span><br><span class="line"><span class="meta">(3)</span>:<span class="string">同步代码块,锁是括号里面的对象</span></span><br><span class="line"><span class="meta">实现方法</span>:<span class="string"></span></span><br><span class="line"><span class="meta">synchronized是JVM内置锁,通过内部对象Monitor(监视器锁)实现,基于进入与退出Monitor对象实现方法与代码块同步,Monitor监视器锁的实现依赖于底层操作系统的Mute</span> <span class="string">lock(互斥锁)实现</span></span><br><span class="line"><span class="attr">反编译的话就可以看到monitorEnter指令和monitorExit指令</span></span><br><span class="line"><span class="meta">---------monitorEnter</span><span class="string"></span></span><br><span class="line"><span class="attr">synchronized</span>:<span class="string">--------代码逻辑</span></span><br><span class="line"><span class="attr">---------monitorExit</span></span><br></pre></td></tr></table></figure><h4 id="Monitor监视器对象"><a href="#Monitor监视器对象" class="headerlink" title="Monitor监视器对象"></a>Monitor监视器对象</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#每一个对象都有一个自己的监视器锁monitor</span></span><br><span class="line"><span class="attr">如果想要进入同步方法,需要先去判断当前线程是不是拿到了对象的monitor监视器锁,如果拿到了才能进入到同步代码块去执行方法,如果没有拿到对象的monitor监视器锁,当前线程就会到SynchronizedQueue(同步队列)中去排队,等待对象的监视器锁释放之后Monitor.Exit之后,</span></span><br><span class="line"><span class="attr">线程才能继续去获取对象的监视器锁,拿到之后执行逻辑代码,执行完之后释放对象的monitor监视器锁.</span></span><br></pre></td></tr></table></figure><h4 id="JVM内置锁的膨胀升级过程"><a href="#JVM内置锁的膨胀升级过程" class="headerlink" title="JVM内置锁的膨胀升级过程"></a>JVM内置锁的膨胀升级过程</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">偏向锁---&gt;轻量级锁---&gt;重量级锁</span></span><br><span class="line"><span class="meta">(1)偏向锁</span>:<span class="string">只有一个线程进入临界区,适用于只有一个线程访问同步代码快的场景</span></span><br><span class="line"><span class="meta">(2)轻量级锁</span>:<span class="string">多线程未竞争或者竞争不激烈,适用于追求响应时间,同步代码的执行速度非常快</span></span><br><span class="line"><span class="meta">(3)重量级锁</span>:<span class="string">多线程竞争,使用追求吞吐量,同步代码块的执行时间比较长</span></span><br></pre></td></tr></table></figure><h4 id="JVM对象加锁原理"><a href="#JVM对象加锁原理" class="headerlink" title="JVM对象加锁原理"></a>JVM对象加锁原理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">认识对象的内存结构</span></span><br><span class="line"><span class="meta">(1)对象头</span>:<span class="string">比如hash值,对象锁,偏向状态,线程ID,锁状态标志等等信息 </span></span><br><span class="line"><span class="meta">(2)对象实际数据</span>:<span class="string">即创建对象时,对象中的成员变量,方法等等.</span></span><br></pre></td></tr></table></figure><p><strong>面试：实例对象是怎样存储的?</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">对象的实例存储在堆空间</span></span><br><span class="line"><span class="attr">对象的元数据存放在方法区(元数据区)</span></span><br><span class="line"><span class="attr">对象的引用存放在栈空间</span></span><br></pre></td></tr></table></figure><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">公平锁</span>:<span class="string">公平锁是FIFO机制,谁先来谁就在队列的前面,就能优先获得锁</span></span><br><span class="line"><span class="meta">非公平锁</span>:<span class="string">非公平锁支持抢占模式,先来的不一定能得到锁</span></span><br><span class="line"><span class="meta">对于ReetrantLock而言</span>:<span class="string">通过构造方法指定该锁是否未为公平锁,默认是非公平锁,非公平锁的优点在于吞吐量大.</span></span><br><span class="line"><span class="meta">对于Synchronized而言</span>:<span class="string">由于其并不像ReetrantLock是通过AQS来实现线程调度,所以没有办法使其变成公平锁</span></span><br></pre></td></tr></table></figure><h4 id="可重入锁与不可重入锁"><a href="#可重入锁与不可重入锁" class="headerlink" title="可重入锁与不可重入锁"></a>可重入锁与不可重入锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">可重入锁</span>:<span class="string">是指同一个线程可以多次去获取同一个锁,可重复可递归调用锁,并且不会发生死锁</span></span><br><span class="line"><span class="attr">ReetrantLock和Synchronized都是可重入锁</span></span><br><span class="line"><span class="meta">不可重入锁(自旋锁)</span>:<span class="string">一个线程不能够重复获取同一个锁使用,只能将锁释放才能获取锁,否则就会发生死锁</span></span><br></pre></td></tr></table></figure><h4 id="读锁与写锁-共享锁与独占锁"><a href="#读锁与写锁-共享锁与独占锁" class="headerlink" title="读锁与写锁(共享锁与独占锁)"></a>读锁与写锁(共享锁与独占锁)</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">读锁(共享锁)</span>:<span class="string">这个锁可以被多个线程共同拥有,最典型的就是ReetrantReadWriteLock中的读锁,是可以被共享的</span></span><br><span class="line"><span class="meta">写锁(独占锁)</span>:<span class="string">就是这个锁只能被一个线程锁拥有,其他线程会阻塞,最典型的就是ReetrantReadWriteLock中的写锁,他就是独占的</span></span><br></pre></td></tr></table></figure><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">读写锁ReetrantLock</span>:<span class="string">读写锁在Java中的具体实现就是ReetrantLock,他即是独占锁又是共享锁,一次只能以恶线程可以占有写模式的读写锁,但是可以多个线程共同占有读模式的读写锁</span></span><br><span class="line"><span class="attr">ReetrantLock读状态与读状态之间共享,但是读状态写与写状态和写状态与写状态之间是互斥的</span></span><br></pre></td></tr></table></figure><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">偏向锁</span>:<span class="string">偏向于第一个访问锁的线程,只有一个线程访问.一段同步代码块一直被一个线程访问,那么该线程就会自动获得锁,降低获取锁的代价</span></span><br></pre></td></tr></table></figure><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">轻量级锁是指当关闭偏向锁功能或者多个线程竞争偏向锁的时候,偏向锁就会升级为轻量级锁，其他线程会通过自旋的方式尝试获取锁,不会阻塞</span></span><br></pre></td></tr></table></figure><h4 id="重量级锁synchronized"><a href="#重量级锁synchronized" class="headerlink" title="重量级锁synchronized"></a>重量级锁synchronized</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">重量级锁是指当锁是轻量级锁的时候,另一个线程虽然是自旋,但是自旋不会一直持续下去,当自旋到一定次数的时候,就会进入阻塞,轻量级锁就会膨胀成重量级锁,重量级锁会让其他自旋的线程也都进入阻塞</span></span><br></pre></td></tr></table></figure><h4 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">分段锁其实是一种锁的设计,并不是一种具体的锁,对于ConcurrentHashMap而言,他并发的实现就是通过分段锁的形式来实现的</span></span><br><span class="line"><span class="meta">比如</span>:<span class="string">在ConcurrentHashMap中使用了一个包含16个锁的数组,每个锁保护散列桶的1/16,这样的话我们最高就可以实现16个线程同时对ConcurrentHashMap进行操作,这样就提高了效率</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java主流锁&quot;&gt;&lt;a href=&quot;#Java主流锁&quot; class=&quot;headerlink&quot; title=&quot;Java主流锁&quot;&gt;&lt;/a&gt;Java主流锁&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;1&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;乐观锁，悲观锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;2&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;读锁(共享锁)，写锁(排他锁)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;3&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;自旋锁,非自旋锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;4&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;无锁--&amp;gt;偏向锁--&amp;gt;轻量级锁--&amp;gt;重量级锁(JVM内置锁的膨胀升级过程)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;5&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;分布式锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;6&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;区间锁(分段锁),在ConcurrentHashMap中有所体现,JUC下面的类基本都有体现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;7&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;重入锁,非重入锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;8&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;公平锁，非公平锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="https://Agonywy.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://Agonywy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>AQS(同步&amp;条件)</title>
    <link href="https://agonywy.github.io/2020/07/18/AQS(%E5%90%8C%E6%AD%A5+%E6%9D%A1%E4%BB%B6)/"/>
    <id>https://agonywy.github.io/2020/07/18/AQS(%E5%90%8C%E6%AD%A5+%E6%9D%A1%E4%BB%B6)/</id>
    <published>2020-07-18T13:42:35.000Z</published>
    <updated>2020-08-16T09:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="隐式锁与显式锁"><a href="#隐式锁与显式锁" class="headerlink" title="隐式锁与显式锁"></a>隐式锁与显式锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">隐式锁</span>:<span class="string">(synchronized,他是基于JVM的内置锁),加锁与解锁的过程不需要我们在代码中认为的控制,jvm会自动去加锁和解锁</span></span><br><span class="line"><span class="meta">显式锁</span>:<span class="string">JUC下面都是显式锁,比如ReetrantLock,一个可重入的悲观锁,整个加锁和解锁过程需要我们手动编写代码去控制,显式锁是通过AQS实现的</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="AQS类关系"><a href="#AQS类关系" class="headerlink" title="AQS类关系"></a>AQS类关系</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"><span class="comment">//AQS:AbstractQueuedSynchronizer</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line">    <span class="comment">//表示当前线程加锁的次数    </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOwnableSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//exclusiveOwnerThread:当前独占锁的线程,由此可知ReetrantLock是个悲观锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS之同步队列"><a href="#AQS之同步队列" class="headerlink" title="AQS之同步队列"></a>AQS之同步队列</h4><p><strong>AQS抽象队列同步器是基于CLH队列去实现的<br>整个AQS分为两个队列,一个是同步队列,另一个是条件队列,只有同步队列的节点才能获取锁</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1: ReentrantLock(以下排队是针对公平锁解释的)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>  </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2:AbstractQueuedSynchronizer:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//尝试获取一把锁</span></span><br><span class="line">    <span class="comment">//addWaiter(Node.EXCLUSIVE)没获取到锁将线程封装成Node放入队列等待</span></span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued</span><br><span class="line">        (addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3:ReentrantLock</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果当前线程之前有一个排队的线程，并且当前线程在队列的开头或队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;<span class="comment">//修改state值</span></span><br><span class="line">            <span class="comment">//设置当前线程是独占锁的线程</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果当前线程就是独占锁的线程,再次试图获取锁就将state+1</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">AQS的核心思想是</span>:<span class="string">如果请求的共享资源空闲,那么就将当前请求资源的线程设置为当前独占锁的线程,将共享资源的状态设置成锁定状态;如果请求的共享资源被占用的话,就需要使用阻塞唤醒机制来保证锁的分配,这个机制主要用的是CLH队列实现的,将暂时获取不到锁的线程加入到队列</span></span><br></pre></td></tr></table></figure><h4 id="CLH"><a href="#CLH" class="headerlink" title="CLH"></a>CLH</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">CLH</span>:<span class="string">是一种基于双向链表结构的队列,AQS中的队列是CLH变体的双向队列FIFO,线程由原来的自旋机制改成阻塞机制实现的.AQS通过将每个请求共享资源的线程封装一个Node节点来实现锁的分配</span></span><br><span class="line"><span class="attr">AQS使用state来表示同步状态,通过内置的FIFO队列来完成资源获取的排队工作,通过CAS完成对state值的修改</span></span><br></pre></td></tr></table></figure><h4 id="AQS数据结构"><a href="#AQS数据结构" class="headerlink" title="AQS数据结构"></a>AQS数据结构</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">AQS中最基本的数据结构就是Node</span>:<span class="string">Node就是上面CLH变体队列中的节点</span></span><br><span class="line"><span class="attr">waitStatus</span>:<span class="string">当前节点在CLH变体队列中的状态</span></span><br><span class="line"><span class="attr">thread</span>:<span class="string">表示位于该节点的阻塞线程</span></span><br><span class="line"><span class="attr">prev</span>:<span class="string">前驱指针</span></span><br><span class="line"><span class="attr">preDecessor</span>:<span class="string">返回前驱节点,没有的话抛出NoPointException</span></span><br><span class="line"><span class="attr">next</span>:<span class="string">后继节点</span></span><br><span class="line"><span class="attr">nextWaiter</span>:<span class="string">指向下一个处于condition状态的节点</span></span><br><span class="line"><span class="attr">addWaiter</span>:<span class="string">就是一个在双端链表添加尾节点的操作</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//信号状态cancelled代表当前节点中的线程已经挂掉了</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//信号状态signal代表当前节点中的线程正常,等待被唤醒</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//信号状态condition代表的不是同步队列,而是条件队列</span></span><br><span class="line">    <span class="comment">//线程池中的队列涉及的就是条件队列,线程在条件队列中阻塞排队</span></span><br><span class="line">    <span class="comment">//只有独占锁才存在condition条件队列</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//setHeadAndPropagate的propagate参数大于0，</span></span><br><span class="line">    <span class="comment">//也就是现在的头节点获取了共享资源，并且之后的节点也可以获取共享资源</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line">    <span class="comment">//当前节点中的线程的状态在CLH变体队列中的状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line">    <span class="comment">//表示位于该节点的阻塞线程</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line">    <span class="comment">//preDecessor:返回前驱节点,没有的话抛出NoPointException</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//addWaiter:就是一个在双端链表添加尾节点的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="state"><a href="#state" class="headerlink" title="state"></a>state</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">state</span>:<span class="string">state的get/set()方法都是Final修饰的,说明子类中无法重写它们.我们可以通过修改State字段表示的同步状态来实现多线程的独占模式和共享模式（加锁过程）</span></span><br><span class="line"><span class="attr">protected</span> <span class="string">final int getState():获取State的值</span></span><br><span class="line"><span class="attr">protected</span> <span class="string">final void setState(int newState):设置State的值</span></span><br><span class="line"><span class="comment">#使用CAS方式更新State:</span></span><br><span class="line"><span class="attr">protected</span> <span class="string">final boolean compareAndSetState(int expect, int update)</span></span><br></pre></td></tr></table></figure><h4 id="加锁-解锁"><a href="#加锁-解锁" class="headerlink" title="加锁/解锁"></a>加锁/解锁</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">加锁：</span></span><br><span class="line"><span class="attr">1</span>:<span class="string">通过ReentrantLock的加锁方法Lock进行加锁操作。</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">会调用到内部类Sync的Lock方法，由于Sync#lock是抽象方法，根据ReentrantLock初始化选择的公平锁和非公平锁,执行相关内部类的Lock方法,本质上都会执行AQS的Acquire方法</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">AQS的Acquire方法会执行tryAcquire方法,但是由于tryAcquire需要自定义同步器实现，因此执行了ReentrantLock中的tryAcquire方法,由于ReentrantLock是通过公平锁和非公平锁内部类实现的tryAcquire方法,因此会根据锁类型不同,执行不同的tryAcquire。</span></span><br><span class="line"><span class="attr">4</span>:<span class="string">tryAcquire是获取锁逻辑，获取失败后，会执行框架AQS的后续逻辑，跟ReentrantLock自定义同步器无关。</span></span><br><span class="line"></span><br><span class="line"><span class="attr">解锁：</span></span><br><span class="line"><span class="attr">1</span>:<span class="string">通过ReentrantLock的解锁方法Unlock进行解锁。</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">Unlock会调用内部类Sync的Release方法，该方法继承于AQS。</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">Release中会调用tryRelease方法，tryRelease需要自定义同步器实现，tryRelease只在ReentrantLock中的Sync实现，因此可以看出，释放锁的过程，并不区分是否为公平锁。</span></span><br><span class="line"><span class="attr">4</span>:<span class="string">释放成功后，所有处理由AQS框架完成，与自定义同步器无关。</span></span><br></pre></td></tr></table></figure><h4 id="Acquired-amp-amp-Release"><a href="#Acquired-amp-amp-Release" class="headerlink" title="Acquired&amp;&amp;Release"></a>Acquired&amp;&amp;Release</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">protected boolean tryAcquire(int arg)</span></span><br><span class="line"><span class="attr">独占方式。arg为获取锁的次数，尝试获取资源，成功则返回True，失败则返回False。</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">protected boolean tryRelease(int arg)</span></span><br><span class="line"><span class="attr">独占方式。arg为释放锁的次数，尝试释放资源，成功则返回True，失败则返回False。</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">protected int tryAcquireShared(int arg)</span></span><br><span class="line"><span class="attr">共享方式。arg为获取锁的次数，尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line"><span class="attr">4</span>:<span class="string">protected boolean tryReleaseShared(int arg)</span></span><br><span class="line"><span class="attr">共享方式。arg为释放锁的次数，尝试释放资源，如果释放后允许唤醒后续等待结点返回True，否则返回False。</span></span><br></pre></td></tr></table></figure><h4 id="线程阻塞放入CHL队列"><a href="#线程阻塞放入CHL队列" class="headerlink" title="线程阻塞放入CHL队列"></a>线程阻塞放入CHL队列</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">当执行Acquire(1)时，会通过tryAcquire获取锁。在这种情况下，如果获取锁失败，就会调用addWaiter加入到等待队列中去。</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法。如果返回False，说明当前线程可以争取共享资源；如果返回True，说明队列中存在有效节点，当前线程必须加入到等待队列中</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">addWaiter就是一个在双端链表添加尾节点的操作，需要注意的是，双端链表的头结点是一个无参构造函数的头结点。</span></span><br></pre></td></tr></table></figure><h4 id="hasQueuedPredecessors"><a href="#hasQueuedPredecessors" class="headerlink" title="hasQueuedPredecessors"></a>hasQueuedPredecessors</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">hasQueuedPredecessors是公平锁加锁时判断等待队列中是否存在有效节点的方法</span></span><br><span class="line"><span class="comment">h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());</span></span><br><span class="line"><span class="comment">为什么要判断的头结点的下一个节点？第一个节点储存的数据是什么？</span></span><br><span class="line"><span class="comment">双向链表中,第一个节点为虚节点,其实并不存储任何信息,只是占位.真正的第一个有数据的节点,是在第二个节点开始的</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node t = tail;</span><br><span class="line">Node h = head;</span><br><span class="line">Node s;</span><br><span class="line"><span class="keyword">return</span> h != t &amp;&amp; ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待队列中线程出队列时机"><a href="#等待队列中线程出队列时机" class="headerlink" title="等待队列中线程出队列时机"></a>等待队列中线程出队列时机</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">上文解释了addWaiter方法，这个方法其实就是把对应的线程以Node的数据结构形式加入到双端队列里，返回的是一个包含该线程的Node。而这个Node会作为参数，进入到acquireQueued方法中。acquireQueued方法可以对排队中的线程进行“获锁”操作。</span></span><br><span class="line"><span class="attr">总的来说，一个线程获取锁失败了，被放入等待队列，acquireQueued会把放入队列中的线程不断去获取锁，直到获取成功</span></span><br></pre></td></tr></table></figure><h4 id="acquireQueued"><a href="#acquireQueued" class="headerlink" title="acquireQueued"></a>acquireQueued</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">for(</span>:<span class="string">:)通过自旋的方式一直找到第一个节点,他的前置节点就是头节点,我们要让这个节点中的线程去获取锁</span></span><br><span class="line"><span class="attr">跳出当前循环的条件是当“前置节点是头结点，且当前线程获取锁成功”。为了防止因死循环导致CPU资源被浪费，我们会判断前置节点的状态来决定是否要将当前线程挂起(前驱节点的waitStatus为-1）)</span></span><br><span class="line"><span class="attr">当前节点获取到锁之后,Node中将thread置为null,然后将head头节点指到这个节点上,这个节点就成了新的头节点,同时也达到了将该节点移除的效果</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 标记是否成功拿到资源</span></span><br><span class="line"><span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 标记等待过程中是否中断过</span></span><br><span class="line"><span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 开始自旋，要么获取锁，要么中断</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的前驱节点</span></span><br><span class="line">        <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">        <span class="comment">// 如果p是头结点，说明当前节点在真实数据队列的首部，就尝试获取锁（别忘了头结点是虚节点）</span></span><br><span class="line">        <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">            <span class="comment">// 获取锁成功，头指针移动到当前node,setHead方法是把当前节点置为虚节点</span></span><br><span class="line">            setHead(node);</span><br><span class="line">            p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">            failed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> interrupted;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 说明p为头节点且当前没有获取到锁（可能是非公平锁被抢占了）或者是p不为头结点，</span></span><br><span class="line">        <span class="comment">//这个时候就要判断当前node是否要被阻塞（</span></span><br><span class="line">        <span class="comment">//被阻塞条件：前驱节点的waitStatus为-1，防止无限循环浪费资源.</span></span><br><span class="line">        <span class="comment">//parkAndCheckInterrupt主要用于挂起当前线程，阻塞调用栈，返回当前线程的中断状态</span></span><br><span class="line">        <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt())</span><br><span class="line">            interrupted = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (failed)</span><br><span class="line">            <span class="comment">//如果处于排队等候机制中的线程一直无法获取锁</span></span><br><span class="line">            <span class="comment">//线程所在节点的状态会变成取消状态，取消状态的节点会从队列中释放</span></span><br><span class="line">cancelAcquire(node);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AQS之条件队列"><a href="#AQS之条件队列" class="headerlink" title="AQS之条件队列"></a>AQS之条件队列</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">条件队列---------&gt;线程池阻塞队列的关键组件</span></span><br><span class="line"><span class="attr">等待条件的过程</span></span><br><span class="line"><span class="attr">1</span>:<span class="string">线程在操作条件队列之前首先需要获取独占锁,否则在获取独占锁的时候就已经被挂起了</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">成功获取独占锁以后,如果当前条件还不满足,那该线程就会在该锁的条件队列上阻塞挂起,与此同时释放掉当前获取的锁资源</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">然后等待signal正常唤醒或者由于节点中断加入到同步队列</span></span><br><span class="line"><span class="attr">如果Node被唤醒并且已经转移到了同步队列中,则会执行与独占锁一样的方法acquireQueued()去独占的获取锁</span></span><br><span class="line"></span><br><span class="line"><span class="meta">条件满足后的唤醒过程</span>:<span class="string">把当前条件队列中的第一个有效节点加入到同步队列中去等待被前置节点唤醒,条件队列中所谓的唤醒就是把条件队列移到同步队列中去,让节点有机会去获取锁</span></span><br></pre></td></tr></table></figure><h4 id="条件队列阻塞方法await"><a href="#条件队列阻塞方法await" class="headerlink" title="条件队列阻塞方法await()"></a>条件队列阻塞方法await()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前线程被中断则直接抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//把当前节点加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放掉已经获取的独占锁资源</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果不在同步队列中则不断挂起</span></span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//中断处理，另一种跳出循环的方式</span></span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到这里说明节点已经条件满足被加入到了同步队列中或者中断了</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="comment">//走到这里说明已经成功获取到了独占锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节点加入条件队列之后持续挂起"><a href="#节点加入条件队列之后持续挂起" class="headerlink" title="节点加入条件队列之后持续挂起"></a>节点加入条件队列之后持续挂起</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果不在同步队列就继续挂起（signal操作会把节点加入同步队列）</span></span><br><span class="line"><span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//中断处理</span></span><br><span class="line">    <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列转移"><a href="#队列转移" class="headerlink" title="队列转移"></a>队列转移</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">满足条件之后条件队列中的第一个有效节点会被放入同步队列中去</span></span><br><span class="line"><span class="attr">然后和同步队列中的其他节点一样自旋等待获取锁</span></span><br><span class="line"><span class="attr">1</span>:<span class="string">signal操作将条件队列中第一个有效的节点唤醒,然后直接放入了同步队列中</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">节点中断:返回THROW_IE,由signal加入同步队列则返回peinterrupt</span></span><br><span class="line"><span class="attr">设置节点状态为0,如果成功则加入同步队列,如果设置状态失败了,说明节点已经被signal唤醒,是由signal加入同步队列的</span></span><br></pre></td></tr></table></figure><h4 id="条件队列唤醒方法signal"><a href="#条件队列唤醒方法signal" class="headerlink" title="条件队列唤醒方法signal()"></a>条件队列唤醒方法signal()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果不是独占锁则抛出异常，再次说明条件队列只适用于独占锁</span></span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="comment">//如果条件队列不为空，则进行唤醒操作</span></span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法就是把一个有效节点从条件队列中删除并加入同步队列</span></span><br><span class="line"><span class="comment">//如果失败则会查找条件队列上等待的下一个节点直到队列为空</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;(first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将节点加入同步队列</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//修改节点状态，这里如果修改失败只有一种可能就是该节点被取消</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//跟独占锁入队方法一样</span></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="comment">//如果前置节点被取消或者修改状态失败则直接唤醒当前节点</span></span><br><span class="line">    <span class="comment">//此时当前节点已经处于同步队列中，唤醒会进行锁获取或者正确的挂起操作</span></span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="判断节点是不是满足条件被放入了同步队列"><a href="#判断节点是不是满足条件被放入了同步队列" class="headerlink" title="判断节点是不是满足条件被放入了同步队列"></a>判断节点是不是满足条件被放入了同步队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断节点是否在同步队列中</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isOnSyncQueue</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//快速判断1：节点状态或者节点没有前置节点</span></span><br><span class="line">    <span class="comment">//原因：同步队列是有头节点的，而条件队列没有</span></span><br><span class="line">    <span class="keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//快速判断2：next字段只有同步队列才会使用，条件队列中使用的是nextWaiter字段</span></span><br><span class="line">    <span class="keyword">if</span> (node.next != <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">//上面如果无法判断则进入复杂判断</span></span><br><span class="line">    <span class="keyword">return</span> findNodeFromTail(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;隐式锁与显式锁&quot;&gt;&lt;a href=&quot;#隐式锁与显式锁&quot; class=&quot;headerlink&quot; title=&quot;隐式锁与显式锁&quot;&gt;&lt;/a&gt;隐式锁与显式锁&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;隐式锁&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;(synchronized,他是基于JVM的内置锁),加锁与解锁的过程不需要我们在代码中认为的控制,jvm会自动去加锁和解锁&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;显式锁&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;JUC下面都是显式锁,比如ReetrantLock,一个可重入的悲观锁,整个加锁和解锁过程需要我们手动编写代码去控制,显式锁是通过AQS实现的&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="多线程" scheme="https://Agonywy.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
      <category term="多线程" scheme="https://Agonywy.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>redis-List</title>
    <link href="https://agonywy.github.io/2020/07/09/redis-list/"/>
    <id>https://agonywy.github.io/2020/07/09/redis-list/</id>
    <published>2020-07-09T11:12:35.000Z</published>
    <updated>2020-08-16T15:08:42.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="List（可以实现队列和栈）"><a href="#List（可以实现队列和栈）" class="headerlink" title="List（可以实现队列和栈）"></a>List（可以实现队列和栈）</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">List是一个有序(按照加入的时间顺序排序)的数据结构,Redis采用quickList(快速链表)和(压缩列表)zipList作为List的底层实现</span></span><br><span class="line"><span class="attr">可以通过设置每个zipList的最大容量,quickList的数据压缩范围,提升数据存储效率</span></span><br><span class="line"><span class="meta">(1)</span>:<span class="string">list-compress-depth指定在每个list中的两端没有被压缩的节点的个数</span></span><br><span class="line"><span class="meta">list-compress-depth</span> <span class="string">0</span></span><br><span class="line"><span class="attr">quicklist</span> <span class="string">默认的压缩深度是0,也就是不压缩</span></span><br><span class="line"><span class="meta">(2)-n</span>:<span class="string">每个ziplist占用的内存不超过2^(n+1)kb</span></span><br><span class="line"><span class="meta">list-max-ziplist-size</span> <span class="string">-2</span></span><br><span class="line"><span class="attr">quicklist内部默认单个ziplist长度为8k字节,超出了这个字节数,就会新起一个ziplist</span></span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>基本操作</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">以Lpush为例,比如Lpush</span> <span class="string">key a b c d,意思就是从左边放入,那么双端队列中就是d c b a</span></span><br><span class="line"><span class="meta">然后Lrange</span> <span class="string">key 0 -1全部查询,从左边开始查询,依次就是d b c a</span></span><br><span class="line"><span class="meta">如果是Lpop</span> <span class="string">key,那就会弹出d,再次执行Lpop key就会弹出c</span></span><br><span class="line"><span class="attr">Llen,Ltrim,Lpushx,Lindex,Lindext等等</span></span><br><span class="line"><span class="meta">解释一下Ltrim</span> <span class="string">start stop:截取start到stop的数据</span></span><br><span class="line"><span class="attr">Ltrim</span> <span class="string">key 0 3:只保留0-3这4个元素</span></span><br></pre></td></tr></table></figure><p><strong>quickList</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">quickList</span>:<span class="string">主要由四种数据结构实现,quicklist,qucikNode,quicklistLZF以及ziplist</span></span><br></pre></td></tr></table></figure><p><strong>quicklist结构</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklist &#123;</span><br><span class="line">    <span class="comment">/* 整个链表的头部节点quickListNode */</span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">/* 整个链表的尾部节点 */</span></span><br><span class="line">    quicklistNode *tail;</span><br><span class="line">    <span class="comment">/* 整个链表中的所有的entry的数量 */</span></span><br><span class="line">    unsigned <span class="keyword">long</span> count;</span><br><span class="line">    <span class="comment">/* quicklistNode的数量 */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">/* 用户存放配置文件中的list-max-ziplist-size的值 */</span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>; </span><br><span class="line">    <span class="comment">/* 压缩节点的深度，表示表头或者表尾有几个节点不被压缩;</span></span><br><span class="line"><span class="comment">     * 存放list-compress-depth参数的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> compress : <span class="number">16</span>; </span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure><p><strong>qucikListNode</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklistNode &#123;</span><br><span class="line">    <span class="comment">/* 指向前面的quicklistNode */</span></span><br><span class="line">    struct quicklistNode *prev;</span><br><span class="line">    <span class="comment">/* 指向后面的quicklistNode */</span></span><br><span class="line">    struct quicklistNode *next;</span><br><span class="line">    <span class="comment">/* 如果对数据进行压缩，zl指向ziplist；</span></span><br><span class="line"><span class="comment">     * 如果不对数据进行压缩，zl指向quicklistLZF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unsigned <span class="keyword">char</span> *zl;</span><br><span class="line">    <span class="comment">/* zl指向的ziplist的总大小(包括zlbytes,zltail,zllen,zlend和各个entry的长度之和);</span></span><br><span class="line"><span class="comment">     * 如果ziplist被压缩了，那么这个sz值仍然是表示压缩前的ziplist的大小;</span></span><br><span class="line"><span class="comment">     * ziplist没有被压缩时，sz表示的就是ziplist占据的字节数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> sz;</span><br><span class="line">    <span class="comment">/* ziplist内部entry的个数 */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> count : <span class="number">16</span>;</span><br><span class="line">    <span class="comment">/* 是否可以对ziplist的压缩;</span></span><br><span class="line"><span class="comment">     * encoding = QUICKLIST_NODE_ENCODING_LZF，表示可以压缩;</span></span><br><span class="line"><span class="comment">     * encoding = QUICKLIST_NODE_ENCODING_RAW, 表示不压缩    </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> encoding : <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* quicklistNode是否作为一个容器使用;</span></span><br><span class="line"><span class="comment">     * 如果quicklistNode不作为容器使用，container = QUICKLIST_NODE_CONTAINER_NONE;         * 如果quicklistNode作为容器使用, container = QUICKLIST_NODE_CONTAINER_ZIPLIST;</span></span><br><span class="line"><span class="comment">     * 设计quicklist的目的就是为了避免单独使用adlist和ziplist，所以quicklistNode一般</span></span><br><span class="line"><span class="comment">     * 用作容器，指向一个包含少量entry的ziplist或者是quicklistLZF</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span></span><br><span class="line">    <span class="comment">/* 当使用lindex这样的命令查看某一项本来压缩的数据的时候，需要把数据暂时解压，</span></span><br><span class="line"><span class="comment">     * 这时就设置recompress=1做一个标记，等有机会再把数据进行压缩</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> recompress : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 只用于redis的自动化测试 */</span></span><br><span class="line">    unsigned <span class="keyword">int</span> attempted_compress : <span class="number">1</span>;</span><br><span class="line">    unsigned <span class="keyword">int</span> extra : <span class="number">10</span>;</span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure><p><strong>quickListLZF</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct quicklistLZF &#123;</span><br><span class="line">     <span class="comment">/* ziplist压缩之后的存储在compressed中的数据长度；</span></span><br><span class="line"><span class="comment">      * 压缩之前的数据的长度存储在quicklistNode的成员sz中</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     unsigned <span class="keyword">int</span> sz; </span><br><span class="line">     <span class="comment">/* 柔性数组 */</span></span><br><span class="line">     <span class="keyword">char</span> compressed[];</span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure><p><strong>ziplist</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zipllist</span>:<span class="string">压缩列表,本质上就是一个字节数组,是redis为了节约内存涉及的一种数据结构,可以包含任意多个元素,每个元素都可以是一个字节数组或一个整数,redis中的有序集合,哈希以及列表(List)都直接或者间接的使用到了压缩列表.</span></span><br><span class="line"><span class="attr">当有序集合或者哈希的元素数目都比较少并且都是短字符串的时候,redis就使用压缩列表作为其底层数据存储方式,列表使用quickList(快速链表)数据结构存储,而快速链表就是双端链表与压缩列表的组合</span></span><br></pre></td></tr></table></figure><p><strong>ziplist数据结构</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;zlbytes&gt;&lt;zltail&gt;&lt;zllen&gt;&lt;entry&gt;...&lt;entry&gt;&lt;zlend&gt;</span></span><br><span class="line"><span class="meta">&lt;zlbytes&gt;</span>:<span class="string">32bit,表示ziplist数据结构占用的字节总数</span></span><br><span class="line"><span class="meta">&lt;zltail&gt;</span>:<span class="string">32bit,表示ziplist中 最后一项(entry)在ziplist中的偏移字节数,方便在ziplist尾端进行操作</span></span><br><span class="line"><span class="meta">&lt;zllen&gt;</span>:<span class="string">16bit,表示ziplist中数据项(entry)的个数</span></span><br><span class="line"><span class="meta">&lt;entry&gt;</span>:<span class="string">数据项</span></span><br><span class="line"><span class="meta">&lt;zlend&gt;</span>:<span class="string">ziplist最后一个字节,是一个结束标记,值固定是255</span></span><br></pre></td></tr></table></figure><p><strong>数据项<entey></entey></strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&lt;prevrawlen&gt;&lt;len&gt;&lt;data&gt;</span></span><br><span class="line"><span class="meta">&lt;prevrawlen&gt;</span>:<span class="string">表示前面的数据项所占用的总字节数,这个字段的用处是为了让ziplist能够从后向前遍历,后面的entry数据项向前偏移prevrawlen个字节就可以找到前一个数据项</span></span><br><span class="line"><span class="meta">&lt;len&gt;</span>:<span class="string">表示当前数据项的数据&lt;data&gt;的长度</span></span><br><span class="line"><span class="meta">&lt;data&gt;</span>:<span class="string">表示当前数据项的数据</span></span><br></pre></td></tr></table></figure><p><strong><prevrawlen></prevrawlen></strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;prevrawlen&gt;</span>:<span class="string">他是怎么进行变长编码的?</span></span><br><span class="line"><span class="meta">情况1</span>:<span class="string">如果前一个数据项占用字节数小于254,那么&lt;prevrawlen&gt;就只用一个字节来表示,这个字节的值就是前一个数据项占用的字节数</span></span><br><span class="line"><span class="meta">情况2</span>:<span class="string">如果前一个数据项占用的字节数大于等于254,那么&lt;prevrawlen&gt;就会用5个字节来表示,第一个字节的数目就是254来作为这种情况的一个标记,而后面4个字节组成一个整形值来表示前一个数据项所占用的字节数</span></span><br><span class="line"><span class="attr">为什么没有255的情况呢?</span></span><br><span class="line"><span class="attr">这是因为前面ziplist的结构中的&lt;zlend&gt;使用255来作为结束标记了</span></span><br></pre></td></tr></table></figure><p><strong><len></len></strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">|00pppppp|</span>:<span class="string">第1个字节最高两个bit是00，那么&lt;len&gt;字段只有1个字节，剩余的6个bit用来表示长度值，最高可以表示63 (2^6-1)。</span></span><br><span class="line"><span class="meta">|01pppppp|qqqqqqqq|</span>:<span class="string">第1个字节最高两个bit是01，那么&lt;len&gt;字段占2个字节，总共有14个bit用来表示长度值，最高可以表示16383 (2^14-1)。</span></span><br><span class="line"><span class="meta">|10------|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</span>:<span class="string">第1个字节最高两个bit是10，那么len字段占5个字节，总共使用32个bit来表示长度值（6个bit舍弃不用），最高可以表示2^32-1。需要注意的是：在前三种情况下，&lt;data&gt;都是按字符串来存储的；从下面第4种情况开始，&lt;data&gt;开始变为按整数来存储了。</span></span><br><span class="line"><span class="meta">|11000000|</span>:<span class="string">&lt;len&gt;字段占用1个字节，值为0xC0，后面的数据&lt;data&gt;存储为2个字节的int16_t类型。</span></span><br><span class="line"><span class="meta">|11010000|</span>:<span class="string">&lt;len&gt;字段占用1个字节，值为0xD0，后面的数据&lt;data&gt;存储为4个字节的int32_t类型。</span></span><br><span class="line"><span class="meta">|11100000|</span>:<span class="string">&lt;len&gt;字段占用1个字节，值为0xE0，后面的数据&lt;data&gt;存储为8个字节的int64_t类型。</span></span><br><span class="line"><span class="meta">|11110000|</span>:<span class="string">&lt;len&gt;字段占用1个字节，值为0xF0，后面的数据&lt;data&gt;存储为3个字节长的整数。</span></span><br><span class="line"><span class="meta">|11111110|</span>:<span class="string">&lt;len&gt;字段占用1个字节，值为0xFE，后面的数据&lt;data&gt;存储为1个字节的整数。</span></span><br><span class="line"><span class="meta">|1111xxxx|(xxxx的值在0001和1101之间)</span>:<span class="string">这是一种特殊情况,xxxx从1到13一共13个值,这时就用这13个值来表示真正的数据.注意,这里是表示真正的数据,而不是数据长度了,也就是说,在这种情况下,后面不再需要一个单独的&lt;data&gt;字段来表示真正的数据了,而是&lt;len&gt;和&lt;data&gt;合二为一了,另外,由于xxxx只能取0001和1101这13个值了(其它可能的值和其它情况冲突了),比如0000和1110分别同前面第7种第8种情况冲突,1111跟结束标记冲突,而小数值应该从0开始,因此这13个值分别表示0到12,即xxxx的值减去1才是它所要表示的那个整数数据的值.</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;List（可以实现队列和栈）&quot;&gt;&lt;a href=&quot;#List（可以实现队列和栈）&quot; class=&quot;headerlink&quot; title=&quot;List（可以实现队列和栈）&quot;&gt;&lt;/a&gt;List（可以实现队列和栈）&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;List是一个有序(按照加入的时间顺序排序)的数据结构,Redis采用quickList(快速链表)和(压缩列表)zipList作为List的底层实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;可以通过设置每个zipList的最大容量,quickList的数据压缩范围,提升数据存储效率&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;(1)&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;list-compress-depth指定在每个list中的两端没有被压缩的节点的个数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;list-compress-depth&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;quicklist&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;默认的压缩深度是0,也就是不压缩&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;(2)-n&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;每个ziplist占用的内存不超过2^(n+1)kb&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;list-max-ziplist-size&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;-2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;quicklist内部默认单个ziplist长度为8k字节,超出了这个字节数,就会新起一个ziplist&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://Agonywy.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://Agonywy.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis-String基本类</title>
    <link href="https://agonywy.github.io/2020/07/07/redis-String%E5%9F%BA%E6%9C%AC%E7%B1%BB/"/>
    <id>https://agonywy.github.io/2020/07/07/redis-String%E5%9F%BA%E6%9C%AC%E7%B1%BB/</id>
    <published>2020-07-07T11:12:35.000Z</published>
    <updated>2020-08-24T09:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis是非关系型的键值对数据库,可以根据key以O(1)的时间复杂度取出或插入关联值</span></span><br><span class="line"><span class="attr">redis里面的key其实都会转成String类型，在redis中自定义了一个数据类结构sds</span></span><br><span class="line"><span class="attr">sds</span>:<span class="string">simple dynamic string简单动态字符传串,而不是简单的使用char[]数组</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="sds结构"><a href="#sds结构" class="headerlink" title="sds结构"></a>sds结构</h4><p><strong>1. redis3.2版本之前sds的结构:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sdshdr&#123;</span><br><span class="line"><span class="keyword">int</span> len;<span class="comment">//表示数据长度</span></span><br><span class="line"><span class="keyword">int</span> free;<span class="comment">//表示剩余空间</span></span><br><span class="line"><span class="keyword">char</span> buf[];<span class="comment">//存放字符</span></span><br><span class="line">&#125;</span><br><span class="line">缺点:描述数据的字段占用内存空间很大,<span class="keyword">int</span>就<span class="number">4</span>个字节</span><br></pre></td></tr></table></figure><p><strong>redis3.2之后sds的结构：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">一个header。通常包含字符串的长度(len),最大容量(alloc),flags和一个字符数组</span></span><br><span class="line"><span class="attr">sds中有一个字段flags总是占用一个字节,其中低3位来表示header的5种类型</span></span><br><span class="line"><span class="comment">#define SDS_TYPE_5  0</span></span><br><span class="line"><span class="comment">#define SDS_TYPE_8  1</span></span><br><span class="line"><span class="comment">#define SDS_TYPE_16 2</span></span><br><span class="line"><span class="comment">#define SDS_TYPE_32 3</span></span><br><span class="line"><span class="comment">#define SDS_TYPE_64 4</span></span><br><span class="line"><span class="attr">这个字符数组的长度等于最大容量+1,真正有效的字符串数据,其长度通常小于最大容量,在真正的字符串数据之后,是空余未用的字节（一般以字节0填充）,允许在不重新分配内存的前提下让字符串数据向后做有限的扩展.在真正的字符串数据之后,还有一个NULL结束符,即ASCII码为0的’\0’字符,这是为了和传统C字符串兼容,之所以字符数组的长度比最大容量多1个字节,就是为了在字符串长度达到最大容量时仍然有1个字节存放NULL结束符</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sds一共有<span class="number">5</span>种类型的header,之所以有<span class="number">5</span>种,是为了能让不同长度的字符串可以使用不同大小的header,这样,短字符串就能使用较小的header,从而节省内存.</span><br><span class="line">typedef <span class="keyword">char</span> *sds;</span><br><span class="line"><span class="comment">//意思就是当string.size()&lt;2^5的时候使用sdshdr5这个header</span></span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr5 </span>&#123;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr8 </span>&#123;</span><br><span class="line">    uint8_t len; <span class="comment">//表示字符串的真正长度,用8bit表示</span></span><br><span class="line">    uint8_t alloc;<span class="comment">//表示字符串的最大容量</span></span><br><span class="line">    unsigned <span class="keyword">char</span> flags; <span class="comment">//使用低3位来表示header的类型</span></span><br><span class="line">    <span class="comment">//flags就存放实际存储数据的char[]buf的前面一个字节</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr16 </span>&#123;</span><br><span class="line">    uint16_t len; <span class="comment">//用16bit表示</span></span><br><span class="line">    uint16_t alloc; </span><br><span class="line">    unsigned <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr32 </span>&#123;</span><br><span class="line">    uint32_t len; <span class="comment">//用32bit表示</span></span><br><span class="line">    uint32_t alloc; </span><br><span class="line">    unsigned <span class="keyword">char</span> flags;</span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct <span class="title">__attribute__</span> <span class="params">((__packed__)</span>) sdshdr64 </span>&#123;</span><br><span class="line">    uint64_t len; <span class="comment">//用64bit表示</span></span><br><span class="line">    uint64_t alloc;</span><br><span class="line">    unsigned <span class="keyword">char</span> flags; </span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="sds优点"><a href="#sds优点" class="headerlink" title="sds优点"></a>sds优点</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">sds是一个二进制安全数据结构,通过len字段避免了char[]数组中以‘/0’字符为结束标志的影响</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">redis动态扩容,避免了频繁的内存分配: char[]数组扩容需要重新分配内存,redis通过free解决扩容的问题,redis扩容会先去看free+length能不能容纳字符串,如果就就不扩容,如果不够才会扩容,扩容超过1M,redis不再双倍扩容而是每次扩容1M</span></span><br></pre></td></tr></table></figure><h4 id="redis-Key-Value"><a href="#redis-Key-Value" class="headerlink" title="redis(Key-Value)"></a>redis(Key-Value)</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">redis中key的存储和Java中的HashMap结构类似,其实就是hash表</span></span><br><span class="line"><span class="attr">redis底层其实是基于数组存储key的,key可能是String类型,浮点类型等等各种类型,其实redis中就是对key进行hash,得到一个自然数,然后会对数组长度求余,这个key就转变成了数组的下标去使用,这样对key查询的复杂度就降低到了O(1)</span></span><br><span class="line"><span class="attr">当出现hash冲突的时候就使用到了链表,如果内容hash值相同但是key值不同的话,依旧会使用链表将key放入同一个桶中</span></span><br></pre></td></tr></table></figure><h4 id="redisDB"><a href="#redisDB" class="headerlink" title="redisDB"></a>redisDB</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">redis中有<span class="number">16</span>个redisBD,所有的数据都是在redisDB中来存储的</span><br><span class="line">typedef struct redisDb &#123;</span><br><span class="line">    <span class="keyword">int</span> id;<span class="comment">// 保存着数据库以整数表示的号码</span></span><br><span class="line">    <span class="comment">// dict:字典----保存着数据库中的所有键值对数据</span></span><br><span class="line">    <span class="comment">// 这个属性也被称为键空间（key space）</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    dict *expires;<span class="comment">//存储过期时间</span></span><br><span class="line">    dict *blocking_keys;<span class="comment">// 保存着键的过期信息</span></span><br><span class="line">    dict *ready_keys;<span class="comment">// 实现列表阻塞原语，如 BLPOP</span></span><br><span class="line">    dict *watched_keys;<span class="comment">// 用于实现 WATCH 命令</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure><h4 id="dict-字典数据结构"><a href="#dict-字典数据结构" class="headerlink" title="dict-字典数据结构"></a>dict-字典数据结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dict&#123;</span><br><span class="line">dictType *type;<span class="comment">//特定于类型的处理函数,里面就是hash函数</span></span><br><span class="line"><span class="keyword">void</span> *privdata;<span class="comment">//私有数据</span></span><br><span class="line">dictht ht[<span class="number">2</span>];<span class="comment">//其实就是个2个哈希表--hashTable</span></span><br><span class="line"><span class="keyword">long</span> rehashidx;<span class="comment">//记录rehash的标志,-1表示rehash未进行</span></span><br><span class="line">unsigned <span class="keyword">long</span> iterators;<span class="comment">//当前正在运作的安全迭代器的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="dictht-哈希表结构"><a href="#dictht-哈希表结构" class="headerlink" title="dictht-哈希表结构"></a>dictht-哈希表结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedet struct dictht&#123;</span><br><span class="line">    dicEntry **table;<span class="comment">//哈希表节点指针数组(俗称桶,bucket)</span></span><br><span class="line">    unsigned <span class="keyword">long</span> size; <span class="comment">//指针数组的大小</span></span><br><span class="line">    unsigned <span class="keyword">long</span> sizemask;<span class="comment">//指针数组的长度掩码,用于计算哈希值</span></span><br><span class="line">    unsigned <span class="keyword">long</span> used;<span class="comment">//哈希表现有的节点数量(已经使用的数组size)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ht-2-–-哈希表"><a href="#ht-2-–-哈希表" class="headerlink" title="ht[2] – 哈希表"></a>ht[2] – 哈希表</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">新创建的两个哈希表都没有为table属性分配任何空间</span></span><br><span class="line"><span class="attr">ht[0]--&gt;table的空间将在第一次往字典添加键值对时进行</span></span><br><span class="line"><span class="attr">ht[1]--&gt;table的空间分配将在rehash开始时进行</span></span><br><span class="line"><span class="attr">开始rehash,将字典的rehashindex设置为0,标志着rehash的开始,然后才会为</span></span><br><span class="line"><span class="attr">当rehash完成之后,释放h[0]的空间,用h[1]来代替h[0],使用原来的h[1]称为新的ht[0]</span></span><br><span class="line"><span class="attr">然后创建一个新的空的hash表,并将它设置成ht[1],将字典的rehashindex属性设置为-1</span></span><br><span class="line"><span class="attr">标识rehash已经停止</span></span><br></pre></td></tr></table></figure><h4 id="dictEntry–哈希表节点"><a href="#dictEntry–哈希表节点" class="headerlink" title="dictEntry–哈希表节点"></a>dictEntry–哈希表节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct dictEntry&#123;</span><br><span class="line">    <span class="comment">//键:redis里面所有的key都是一个String,key指针指向一个sds结构</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    union &#123;</span><br><span class="line">        <span class="comment">//redis中的数据有5种类型,val指针指向要存储的数据</span></span><br><span class="line">        <span class="comment">//val指向了一个redisObject对象,这里就是我们要存储的对象</span></span><br><span class="line">        <span class="keyword">void</span> *val; </span><br><span class="line">        unint64_t u64;</span><br><span class="line">        int64_t s64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    struct dictEntry *next;<span class="comment">//后继节点,链指针,解决哈希冲突用链表</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><h4 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Redis 对象，占用16个字节</span></span><br><span class="line">typedef struct redisObject &#123;</span><br><span class="line">    unsigned type:<span class="number">4</span>;<span class="comment">//当前数据的类型(Stirng,List,Set,Zset,Hash)</span></span><br><span class="line">    unsigned encoding:<span class="number">4</span>;<span class="comment">//记录了对象所保存的值的编码</span></span><br><span class="line">    unsigned lru:LRU_BITS;<span class="comment">//LRU,内存淘汰的时候用的</span></span><br><span class="line">    <span class="keyword">int</span> refcount;<span class="comment">//引用计数,通过引用计数法释放内存的</span></span><br><span class="line">    <span class="comment">//ptr指向实际保存值的数据结构</span></span><br><span class="line">    <span class="comment">//这个数据结构由type属性和encoding属性决定</span></span><br><span class="line">    <span class="comment">//比如:如果一个redisObject的type为list,encoding为linkedList</span></span><br><span class="line">    <span class="comment">//那么这个ptr就会指向这个双端链表</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><strong>对象类型</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define REDIS_STRING 0  // 字符串</span></span><br><span class="line"><span class="comment">#define REDIS_LIST 1    // 列表</span></span><br><span class="line"><span class="comment">#define REDIS_SET 2     // 集合</span></span><br><span class="line"><span class="comment">#define REDIS_ZSET 3    // 有序集</span></span><br><span class="line"><span class="comment">#define REDIS_HASH 4    // 哈希表</span></span><br></pre></td></tr></table></figure><p><strong>encoding编码方式</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">不同数据类型所对应实际编码对象</span></span><br><span class="line"><span class="attr">RAW</span>:<span class="string">当string采用原生的标识方式,就用sds来表示</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_RAW 0            // 编码为字符串</span></span><br><span class="line"><span class="attr">INT</span>:<span class="string">string采用数字的表示方式,实际上是一个long型</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_INT 1            // 编码为整数</span></span><br><span class="line"><span class="attr">HT</span>:<span class="string">表示成dict</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_HT 2             // 编码为哈希表</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_ZIPList 3         // 编码为 ziplist</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_LINKEDLIST 4     // 编码为双端链表</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_ZIPLIST 5        // 编码为压缩列表</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_INTSET 6         // 编码为整数集合</span></span><br><span class="line"><span class="comment">#define REDIS_ENCODING_SKIPLIST 7       // 编码为跳跃表</span></span><br></pre></td></tr></table></figure><p><strong>命令看看redisObject的属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;set a aaa</span><br><span class="line">&gt;&gt;&gt;type a<span class="comment">//当前数据的类型(Stirng,List,Set,Zset,Hash)</span></span><br><span class="line">&gt;&gt;&gt;string</span><br><span class="line">&gt;&gt;&gt;object encoding a<span class="comment">//encoding编码方式</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">"embstr"</span>  </span><br><span class="line">&gt;&gt;&gt;set b <span class="number">100</span>     </span><br><span class="line">&gt;&gt;&gt;type b   </span><br><span class="line">&gt;&gt;&gt;string    </span><br><span class="line">&gt;&gt;&gt;object encoding b</span><br><span class="line">&gt;&gt;&gt;<span class="string">"int"</span></span><br></pre></td></tr></table></figure><p><strong>embstr&amp;raw</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">embstr</span>:<span class="string">embedded string,嵌入式的字符串,将SDS结构体嵌入在RedisObject对象中.一次CPU缓存行是64个字节,RedisObject占用8个字节,因此如果字符串小于等于44字节的时候,就会使用embstr,分配的是一块连续的内存空间,同时包含redisObject和SDS结构体</span></span><br><span class="line"><span class="attr">如果字符串对象保存的是一个字符串值,并且这个字符串的长度小于等于44字节,就使用embstr编码</span></span><br><span class="line"><span class="attr">raw</span>:<span class="string">存储大于44字节的字符串,需要分配两次内存空间,分别是redisObject和SDS结构体</span></span><br><span class="line"></span><br><span class="line"><span class="meta">embstr优点</span>:<span class="string">embstr编码将创建字符串对象所需的内存空间分配次数从raw编码的两次降低为一次,内存释放函数也是从两次将为一次;同时也能够更好的医用CPU缓存行,尽量减少内存浪费</span></span><br><span class="line"><span class="meta">embstr缺点</span>:<span class="string">如果字符串的长度增加就需要重新分配内存,sds结构体需要重新分配内存空间,所以embstr编码的字符串对象实际上只读的,redis并没有为embstr编码的字符串对象编写任务的修改程序.当我们对embstr编码的字符串对象执行任何修改命令,redis都会先将对象的embstr编码修改成raw编码,然后再执行修改操作</span></span><br></pre></td></tr></table></figure><p><strong>mset</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis协议采用是客户端-服务器模式,每一次客户端发送一条指令,服务器解析指令并执行,然后向客户端返回结果,这是一种典型的tcp交互方式，每次上下文切换,指令执行都会有很大的开销,如果使用mset请求,与</span> <span class="string">服务器只交互一次,降低了网络,协议解析的开销,从而提高缓存访问效率</span></span><br></pre></td></tr></table></figure><p><strong>bitmap</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">现在系统有千万级的活跃用户,如何实现日活跃统计,为了增强用户粘性,要上线一个连续打卡发放积分的功能,怎么实现连续打卡用户统计?</span></span><br><span class="line"><span class="attr">setbit</span> <span class="string">key offest(偏移量) 0/1</span></span><br><span class="line"><span class="attr">bitmap就是通过最小的单位bit来进行0或者1的设置，表示某个元素对应的值或者状态</span></span><br><span class="line"><span class="meta">统计日活跃度的话</span>:<span class="string">可以把用户id当作偏移量,如用户登录对应位置设置成1,然后用bitcount统计1的个数就可以了,统计连续登录的用户数的话,可以对每个key进行按位与操作,如果结果还是1的话说明这个用户连续登录的,然后将连续登录的情况重新放到一个新的key里面,对这个新的key重新bitcount统计一下就可以了</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;String&quot;&gt;&lt;a href=&quot;#String&quot; class=&quot;headerlink&quot; title=&quot;String&quot;&gt;&lt;/a&gt;String&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;redis是非关系型的键值对数据库,可以根据key以O(1)的时间复杂度取出或插入关联值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;redis里面的key其实都会转成String类型，在redis中自定义了一个数据类结构sds&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;sds&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;simple dynamic string简单动态字符传串,而不是简单的使用char[]数组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="redis" scheme="https://Agonywy.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://Agonywy.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>投票选举&amp;内存快照&amp;事务日志</title>
    <link href="https://agonywy.github.io/2020/06/26/%E6%8A%95%E7%A5%A8%E9%80%89%E4%B8%BE&amp;%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7&amp;%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/"/>
    <id>https://agonywy.github.io/2020/06/26/%E6%8A%95%E7%A5%A8%E9%80%89%E4%B8%BE&amp;%E5%86%85%E5%AD%98%E5%BF%AB%E7%85%A7&amp;%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97/</id>
    <published>2020-06-26T04:12:35.000Z</published>
    <updated>2020-08-08T11:46:36.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zookeeper中服务器角色"><a href="#zookeeper中服务器角色" class="headerlink" title="zookeeper中服务器角色"></a>zookeeper中服务器角色</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">事务请求</span>:<span class="string">比如对数据的增删改</span></span><br><span class="line"><span class="meta">非事务请求</span>:<span class="string">比如查询操作,判断节点是否存在exists操作</span></span><br><span class="line"><span class="attr">Leader</span>:<span class="string">leader服务器是整个zookeeper集群工作机制中的核心,主要工作有两个.(1)Leader服务器是事务请求的唯一调度者和处理者,保证集群事务处理的顺序性(2)Leader服务器还是集群内容各个服务器的调度者,在Leader服务器中有一个SyncRequestProcessor是事务日志记录处理器,这个处理器的主要作用就是将事务请求写到书屋日志文件中,同时还会zookeeper进行数据快照</span></span><br><span class="line"><span class="attr">Follower</span>:<span class="string">follower服务器是zookeeper集群状态的跟随者,主要工作有3个(1)处理客户端非事务请求,妆发事务请求给leader服务器(2)参与事务请求Proposal的投票(3)参与Leader选举投票</span></span><br><span class="line"><span class="attr">Observer</span>:<span class="string">observer服务器从字面意思来看就是充当了一个观察者的角色,观察zookeeper集群的最新状态变化并将这些状态同步过来,observer和follower在工作原理上是一致的,对于非事务请求都可以进行独立的处理，对于事务请求会转发给Leader服务器进行处理.observer和follower最大的区别就是他不参与任何我形式的投票，他只负责处理非事务请求,通常用来提升分布式系统对非事务请求的处理能力</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="服务器状态"><a href="#服务器状态" class="headerlink" title="服务器状态"></a>服务器状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">为了对服务器的状态进行标识,zookeeper提供了4中服务器状态</span><br><span class="line">(1)Looking:寻找Leader状态,当服务器处于该状态时,他会认为集群中没有Leader服务器,因此需要进入Leader选举流程</span><br><span class="line">(2)Following:跟随者状态,表明当前服务器角色是Follower</span><br><span class="line">(3)Leading状态:领导者状态,表明当前服务器是Leader</span><br><span class="line">(4)Observing:观察者状态,表明当前服务器的角色是Observer</span><br></pre></td></tr></table></figure><h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>*<em>什么情况下会发生选举呢? *</em></p><ul><li><p>集群启动</p></li><li><p>Leader挂掉</p></li><li><p>Follower挂掉之后Leader发现已经没有过半的Follower跟随自己了-不能对外提供服务了(领导者选举)</p></li></ul><h4 id="投票选举"><a href="#投票选举" class="headerlink" title="投票选举"></a>投票选举</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">SID</span>:<span class="string">服务器ID,用来唯一标识一台服务器,与myid的值一致</span></span><br><span class="line"><span class="attr">ZXID</span>:<span class="string">事务ID,用来唯一标识一次服务器状态的变更</span></span><br></pre></td></tr></table></figure><h5 id="（1）服务器启动时的选举"><a href="#（1）服务器启动时的选举" class="headerlink" title="（1）服务器启动时的选举"></a>（1）服务器启动时的选举</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">每个server会发出一个投票</span></span><br><span class="line"><span class="attr">每次投票包含的最基本的元素就是所推举的服务器的myid和ZXID事务id</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">接收来自其他服务器的投票</span></span><br><span class="line"><span class="attr">这里会检测投票的有效性,包括检查是否是本轮投票,是否是来自Looking状态的服务器</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">处理投票</span></span><br><span class="line"><span class="attr">优先检查ZXID,ZXID大的优先作为Leader,如果ZXID相同的话,就会比较服务器的myid,myid比较大的服务器就会优先作为Leader服务器</span></span><br><span class="line"><span class="attr">4</span>:<span class="string">统计投票</span></span><br><span class="line"><span class="attr">每次投票后服务器就会统计票数,判断是否已经有过半的机器收到相同的投票信息,如果过半那就选出Leader服务器了</span></span><br><span class="line"><span class="attr">5</span>:<span class="string">改变状态</span></span><br><span class="line"><span class="attr">一旦确定了Leader,每个服务器就会更新自己的状态,如果是Follower,就更新状态为following,如果是leader就会更新成leading</span></span><br></pre></td></tr></table></figure><h5 id="（2）服务器运行中的选举"><a href="#（2）服务器运行中的选举" class="headerlink" title="（2）服务器运行中的选举"></a>（2）服务器运行中的选举</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">变更状态</span></span><br><span class="line"><span class="attr">当Leader服务器挂了之后,剩余的observer服务器会将自己的状态更新成Looking,然后进行Leader选举状态</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">每个server会发出一个投票</span></span><br><span class="line"><span class="attr">在这个过程中需要生成投票信息(myid,ZXID)</span></span><br><span class="line"><span class="attr">3</span>:<span class="string">接收来自各个服务器的投票</span></span><br><span class="line"><span class="attr">4</span>:<span class="string">处理投票</span></span><br><span class="line"><span class="attr">5</span>:<span class="string">统计投票</span></span><br><span class="line"><span class="attr">6</span>:<span class="string">改变服务器状态</span></span><br></pre></td></tr></table></figure><h4 id="内存数据DataTree"><a href="#内存数据DataTree" class="headerlink" title="内存数据DataTree"></a>内存数据DataTree</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper的数据模型是一棵树,zookeeper中存储了整棵树的内容,包括所有节点的路径,节点数据及其ACL信息等,zookeeper会定时的将这些数据存储到磁盘中</span></span><br><span class="line"><span class="attr">DataTree是zookeeper内存数据存储的核心,是一个"树"的数据结果,代表了内存中一份完整的数据,DataTree不包含任何与网络,客户端连接,以及请求处理等等相关的业务逻辑,他是一个独立的zookeeper组件</span></span><br></pre></td></tr></table></figure><p><strong>DataNode</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DataNode</span>:<span class="string">是数据存储的最小单元,DataNode内部除了保存节点的数据内容,ACL列表和节点状态之外,还记录父节点的引用和子节点列表两个属性</span></span><br></pre></td></tr></table></figure><p><strong>DataTree</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DataTree</span>:<span class="string">用于存放zookeeper所有节点的路径,数据内容及其ACL信息等,底层的数据结构其实是一个典型的ConcurrentHashMap键值对结构,在nodes这个Map中,存放着zookeeper服务器上面所有的数据节点,可以说zookeeper数据的所有操作都是对这个Map结构的操作,对于临时节点,DataTree还单独的将所有临时节点保存起来,便于实时访问和及时清理</span></span><br></pre></td></tr></table></figure><p><strong>ZKDataBase</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ZKDataBase</span>:<span class="string">就是zookeeper的内存数据库,负责管理zookeeper的所有会话,DataTree存储以及事务日志.ZKDataBase会定时向磁盘中dump数据快照,同时在zookeeper服务器启动的时候会通过磁盘上的事务日志和快照数据文件恢复成一个完整的内存数据库</span></span><br></pre></td></tr></table></figure><h4 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h4><p><strong>DataDir</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">dataDir这个目录是zookeeper中默认存储事务日志文件的</span></span><br></pre></td></tr></table></figure><p><strong>日志写入</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FileTxnLog</span>:<span class="string">是负责维护事务日志对外的接口,包括日志写入和读取</span></span><br><span class="line"><span class="meta">日志的写入</span>:<span class="string">主要是由append()方法来负责</span></span><br></pre></td></tr></table></figure><p><strong>snapShot–数据快照</strong>’</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">数据快照</span>:<span class="string">是zookeeper数据存储中一个非常核心的运行机制,数据快照用来记录zookeeper服务器上某一个特定时刻的全量内存数据内容,并将其写到指定的磁盘文件中去</span></span><br><span class="line"><span class="meta">快照数据的写入</span>:<span class="string">将内存数据写入快照数据文件其实是一个序列化过程</span></span><br></pre></td></tr></table></figure><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">peerLastZXID</span>:<span class="string">Learner服务器最后处理的ZXID</span></span><br><span class="line"><span class="attr">minCommitedLog</span>:<span class="string">Learner服务器提议缓存队列commitedLog中的最小ZXID</span></span><br><span class="line"><span class="attr">maxCommitedLog</span>:<span class="string">Learner服务器提议缓存队列commitedLog中的最大ZXID</span></span><br></pre></td></tr></table></figure><p><strong>(1)直接差异化同步(DIFF同步)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">场景</span>:<span class="string">peerLastZXID介于minCommitedLog与maxCommitedLog之间</span></span><br></pre></td></tr></table></figure><p><strong>(2)先回滚再差异化同步(DIFF同步)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">场景</span>:<span class="string">leader服务器恰好要将Proposal发给其他Follower服务器进行投票的时候,Leader服务器挂了,Proposal没有同步出去</span></span><br></pre></td></tr></table></figure><p><strong>(3)仅回滚同步(Trunc同步)</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">场景</span>:<span class="string">peerLastZXID大于maxCommitedLog,这种场景其实是先回滚再差异化同步的简化模式,Leader会要求Learner混滚到ZXID值为maxCommitedLog对应的事务操作</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zookeeper中服务器角色&quot;&gt;&lt;a href=&quot;#zookeeper中服务器角色&quot; class=&quot;headerlink&quot; title=&quot;zookeeper中服务器角色&quot;&gt;&lt;/a&gt;zookeeper中服务器角色&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;事务请求&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;比如对数据的增删改&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;非事务请求&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;比如查询操作,判断节点是否存在exists操作&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;Leader&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;leader服务器是整个zookeeper集群工作机制中的核心,主要工作有两个.(1)Leader服务器是事务请求的唯一调度者和处理者,保证集群事务处理的顺序性(2)Leader服务器还是集群内容各个服务器的调度者,在Leader服务器中有一个SyncRequestProcessor是事务日志记录处理器,这个处理器的主要作用就是将事务请求写到书屋日志文件中,同时还会zookeeper进行数据快照&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;Follower&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;follower服务器是zookeeper集群状态的跟随者,主要工作有3个(1)处理客户端非事务请求,妆发事务请求给leader服务器(2)参与事务请求Proposal的投票(3)参与Leader选举投票&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;Observer&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;observer服务器从字面意思来看就是充当了一个观察者的角色,观察zookeeper集群的最新状态变化并将这些状态同步过来,observer和follower在工作原理上是一致的,对于非事务请求都可以进行独立的处理，对于事务请求会转发给Leader服务器进行处理.observer和follower最大的区别就是他不参与任何我形式的投票，他只负责处理非事务请求,通常用来提升分布式系统对非事务请求的处理能力&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="zookeeper" scheme="https://Agonywy.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://Agonywy.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>ACID&amp;CAP&amp;BASE</title>
    <link href="https://agonywy.github.io/2020/06/23/ACID&amp;CAP&amp;BASE%E7%90%86%E8%AE%BA/"/>
    <id>https://agonywy.github.io/2020/06/23/ACID&amp;CAP&amp;BASE%E7%90%86%E8%AE%BA/</id>
    <published>2020-06-23T04:12:35.000Z</published>
    <updated>2020-08-08T11:45:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="zookeeper是什么"><a href="#zookeeper是什么" class="headerlink" title="zookeeper是什么"></a>zookeeper是什么</h4><p>zookeeper是一个分布式服务框架，主要用来解决分布式的应用中经常遇到的一些数据管理问题，比如统一命名服务，集群管理，分布式应用配置项的管理等</p><a id="more"></a><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zookeeper既然是做数据管理的,那么我们可以怎么来理解zookeeper呢?</span></span><br><span class="line"><span class="attr">(1)zookeeper可以理解成是一个数据库,支持节点的增删改查</span></span><br><span class="line"><span class="attr">(2)zookeeper是一个拥有文件系统结构特点的数据库,与文件系统不同的是,zookeeper的节点可以存储数据</span></span><br><span class="line"><span class="attr">(3)zookeeper是一个解决了数据一致性问题的分布式数据库</span></span><br><span class="line"><span class="attr">比如在机器1上面创建了一个节点,其他服务器也会同样创建这个节点,所有的服务器都保持数据一致</span></span><br><span class="line"><span class="attr">(4)zookeeper是一个具有发布和订阅功能的分布式数据库(watch监听机制)</span></span><br><span class="line"><span class="attr">对于客户端而言,一旦zookeeper服务器上数据发生改变，客户端会立刻知道,然后重新从服务器拉取数据</span></span><br></pre></td></tr></table></figure><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">一个强一致性</span>: <span class="string">数据库A发生update，数据库B就立刻进行更新,其他的读取请求会阻塞,必须等到AB两个数据库同步数据之后才可以读取</span></span><br><span class="line"><span class="meta">弱一致性</span>: <span class="string">数据库B不会阻塞读取请求，即便读取的数据不一致也不要紧</span></span><br><span class="line"><span class="meta">最终一致性</span>: <span class="string">数据读取不要求立刻同步数据，只要最终数据不同步,数据是一致的就可以了</span></span><br></pre></td></tr></table></figure><h4 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">事务</span>:<span class="string">是由一系列对系统中的数据进行读写所组成的一个逻辑执行单元，侠义上的事务指的是数据库事务</span></span><br><span class="line"><span class="meta">事务具有四大特征就是ACID</span>:<span class="string"></span></span><br><span class="line"><span class="meta">原子性</span>:<span class="string">是指事务必须是一个原子的操作序列单元,要么全部执行成功,要么全部不成功</span></span><br><span class="line"><span class="meta">一致性</span>:<span class="string">事务的一致性是指事务的执行不能够破坏数据的一致性和完整性,必须是使数据库从一种正确状态变成另一种正确状态</span></span><br><span class="line"><span class="meta">隔离性</span>:<span class="string">事务之间的执行互不影响,一个事务的执行不会对其他事务造成影响</span></span><br><span class="line"><span class="meta">持久性</span>:<span class="string">事务一旦提交，他对数据库中的数据改变是永久性的</span></span><br></pre></td></tr></table></figure><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">读未提交(允许脏读)</span>:<span class="string">是指一个事务处理中读取了另一个未提交的事务的数据</span></span><br><span class="line"><span class="meta">读已提交(不可重复读)</span>:<span class="string">一个事务处理过程中读取了另一个事务已提交的数据</span></span><br><span class="line"><span class="meta">可重复读</span>:<span class="string">一个事务始终可以读取到事务开始时的数据,避免了脏读和不可重复读</span></span><br><span class="line"><span class="meta">串行化</span>:<span class="string">他要求所有的事务都串行执行</span></span><br><span class="line"></span><br><span class="line"><span class="meta">不可重复读与幻读的区别</span>:<span class="string"></span></span><br><span class="line"><span class="meta">不可重复读</span>:<span class="string">查询的数据值发生了改变</span></span><br><span class="line"><span class="meta">幻读</span>:<span class="string">查询数据行数发生了改变</span></span><br></pre></td></tr></table></figure><h4 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Consistency</span>:<span class="string">一致性(强一致性)是指数据在多个副本之间是否能够保持数据一致</span></span><br><span class="line"><span class="attr">Avaliability</span>:<span class="string">可用性是指系统提供的服务必须一直处于可用的状态</span></span><br><span class="line"><span class="attr">Partition</span> <span class="string">Tolerance:分区容错性是指分布式系统在遇到任何网络分区故障的时候,仍然需要能够保证对外提供满足一致性和可用性的服务,除非整个网络环境都发生了故障</span></span><br><span class="line"><span class="meta">网络分区(脑裂)</span>:<span class="string">当网络由于发生异常情况,导致分布式系统中部分节点之间的网络延迟不断增大,最终导致组成分布式系统的所有节点中.只有部分节点之间能够进行正常通信,而另外一些节点之间不能正常通信---我们将这种现象称为网络分区,也就是俗称的"脑裂"</span></span><br></pre></td></tr></table></figure><p>一个系统不可能同时满足一致性，可用性，分区容错性三个需求，但是对于分布式系统而言，分区容错性问题是一个必定会出现的异常情况，所以系统架构设计的时候往往需要在一致性和可用性之间做一个均衡</p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Basically</span> <span class="string">Avaliable:基本可用是指分布式系统在出现不可以预知故障的时候，允许损失一部分可用性，比如响应时间上的损失，功能上的损失</span></span><br><span class="line"><span class="attr">Soft</span> <span class="string">state:弱状态也成为软状态,和硬状态相对,是指允许系统中的数据存在中间状态，并且认为这个中间状态不会影响系统的整体可用性，也就是说允许系统在不同节点的数据副本之间进行数据同步的过程中存在延迟</span></span><br><span class="line"><span class="attr">Eventually</span> <span class="string">consistent:最终一致性强调的是系统中所有的数据副本，在经过一段时间后，最终能够达到一个一致的状态，因此最终一致性的本质是保系统最终数据能够达成一致,而不需要实时保证系统数据的强一致性</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;zookeeper是什么&quot;&gt;&lt;a href=&quot;#zookeeper是什么&quot; class=&quot;headerlink&quot; title=&quot;zookeeper是什么&quot;&gt;&lt;/a&gt;zookeeper是什么&lt;/h4&gt;&lt;p&gt;zookeeper是一个分布式服务框架，主要用来解决分布式的应用中经常遇到的一些数据管理问题，比如统一命名服务，集群管理，分布式应用配置项的管理等&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookeeper" scheme="https://Agonywy.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://Agonywy.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>match查询</title>
    <link href="https://agonywy.github.io/2020/06/21/match%E6%9F%A5%E8%AF%A2/"/>
    <id>https://agonywy.github.io/2020/06/21/match%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-06-21T02:12:35.000Z</published>
    <updated>2020-08-08T06:07:06.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="match查询"><a href="#match查询" class="headerlink" title="match查询"></a>match查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">match查询属于高层查询，他会根据你查询的字段类型不一样，采用不同的查询方式</span></span><br><span class="line"><span class="attr">--查询的是日期或者数值的话，他会将你基于的字符串查询的内容自动转换为日期或者数值对待</span></span><br><span class="line"><span class="attr">你不需要根据你查询字段类型的不同去指定不同的内容,他会自动帮你转换</span></span><br><span class="line"><span class="attr">--如果查询的内容是一个不能被分词的内容,比如keyword,match查询不会对你指定的查询关键字进行分词</span></span><br><span class="line"><span class="attr">--如果查询的内容是一个可以被分词的内容,比如text,match会将你指定的查询内容根据一定的方式去分词,去分词库中匹配指定的内容</span></span><br><span class="line"></span><br><span class="line"><span class="attr">match查询,实际底层就是多个term查询,就是将多个term查询的结果给你封装到了一起</span></span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="match-all查询"><a href="#match-all查询" class="headerlink" title="match_all查询"></a>match_all查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">查询全部内容,不指定任何查询条件</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–metch_all查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#match_all查询</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"match_all"</span>:<span class="string">&#123;&#125;#会把所有的数据都查出来</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–match_all查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchAllQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">//当数据较多时,ES默认只会帮你查询10条数据</span></span><br><span class="line">    <span class="comment">//这里可以设置一下你需要查询出多少条数据</span></span><br><span class="line">    builder.size(<span class="number">20</span>);</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = resp.getHits().getHits().length;</span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="match查询-1"><a href="#match查询-1" class="headerlink" title="match查询"></a>match查询</h4><ul><li><strong>restful风格–metch查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"match"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"smsContent"</span>:<span class="string">"下载安装" #会分词,去分词库中查询内容</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–metch查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">matchQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.matchQuery(<span class="string">"smsContext"</span>,<span class="string">"下载安装"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = resp.getHits().getHits().length;</span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="布尔match查询"><a href="#布尔match查询" class="headerlink" title="布尔match查询"></a>布尔match查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">基于一个字段匹配的内容,采用and或者or的方式进行连接</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–布尔metch查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"match"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"smsContent"</span>:<span class="string">&#123;   #字段</span></span><br><span class="line">    <span class="meta">"query"</span>: <span class="string">"北京 健康", #用query去指定查询内容</span></span><br><span class="line">    <span class="meta">"operator"</span>: <span class="string">"and"#and,既包含北京又包括健康</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–布尔metch查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boolMatchQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.matchQuery(<span class="string">"smsContext"</span>,<span class="string">"北京 健 康"</span>).operator(Operator.AND));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = resp.getHits().getHits().length;</span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="multi-match查询"><a href="#multi-match查询" class="headerlink" title="multi_match查询"></a>multi_match查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">match针对一个Filed做检索,multi_match针对多个key进行检索</span></span><br><span class="line"><span class="attr">多个filed对应一个text,就像Mysql多个key对应一个value</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–multi_match查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"multi_match"</span>:<span class="string">&#123;</span></span><br><span class="line">   <span class="meta">"query"</span>: <span class="string">"北京", #用query去指定查询内容</span></span><br><span class="line"><span class="comment">   #多个字段只要有一个字段满足都会查出来</span></span><br><span class="line">   <span class="meta">"field"</span>: <span class="string">["province","smsContext"]</span></span><br><span class="line">   <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–multi_metch查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiMatchQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.multiMatchQuery(<span class="string">"北京"</span>,<span class="string">"province"</span>,<span class="string">"smsContext"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = resp.getHits().getHits().length;</span><br><span class="line">    System.out.println(length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;match查询&quot;&gt;&lt;a href=&quot;#match查询&quot; class=&quot;headerlink&quot; title=&quot;match查询&quot;&gt;&lt;/a&gt;match查询&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;match查询属于高层查询，他会根据你查询的字段类型不一样，采用不同的查询方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;--查询的是日期或者数值的话，他会将你基于的字符串查询的内容自动转换为日期或者数值对待&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;你不需要根据你查询字段类型的不同去指定不同的内容,他会自动帮你转换&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;--如果查询的内容是一个不能被分词的内容,比如keyword,match查询不会对你指定的查询关键字进行分词&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;--如果查询的内容是一个可以被分词的内容,比如text,match会将你指定的查询内容根据一定的方式去分词,去分词库中匹配指定的内容&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;match查询,实际底层就是多个term查询,就是将多个term查询的结果给你封装到了一起&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>深分页Scrol&amp;deleteByQuery</title>
    <link href="https://agonywy.github.io/2020/06/21/%E6%B7%B1%E5%88%86%E9%A1%B5Scroll%E4%B8%8EdeleteByQuery/"/>
    <id>https://agonywy.github.io/2020/06/21/%E6%B7%B1%E5%88%86%E9%A1%B5Scroll%E4%B8%8EdeleteByQuery/</id>
    <published>2020-06-21T01:22:15.000Z</published>
    <updated>2020-08-08T06:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="深分页Scroll"><a href="#深分页Scroll" class="headerlink" title="深分页Scroll"></a>深分页Scroll</h4><ul><li><strong>深分页scroll查询</strong></li></ul><a id="more"></a><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ES对from+size这种分页方式是有限制的,from和size二者之和不能超过一万,超过一万之后效率及其低下</span></span><br><span class="line"><span class="comment"># 原理：</span></span><br><span class="line"><span class="comment">#  from+size    在ES查询数据的方式，</span></span><br><span class="line"><span class="attr">第一步将用户指定的关键词进行分词，</span></span><br><span class="line"><span class="attr">第二部将词汇去分词库中进行检索，得到多个文档id,</span></span><br><span class="line"><span class="meta">第三步去各个分片中拉去数据，</span> <span class="string">耗时相对较长</span></span><br><span class="line"><span class="meta">第四步根据score</span> <span class="string">将数据进行排序， 耗时相对较长</span></span><br><span class="line"><span class="meta">第五步根据from</span> <span class="string">和size 的值 将部分数据舍弃，</span></span><br><span class="line"><span class="attr">第六步，返回结果。</span></span><br><span class="line"><span class="comment">#  scroll+size 在ES查询数据的方式</span></span><br><span class="line"><span class="attr">第一步将用户指定的关键词进行分词，</span></span><br><span class="line"><span class="attr">第二部将词汇去分词库中进行检索，得到多个文档id,</span></span><br><span class="line"><span class="attr">第三步，将文档的id存放在一个ES的上下文中,可以理解为存放在ES的内存中</span></span><br><span class="line"><span class="attr">第四步，根据指定的size去ES中检索指定个数的数据，拿完数据的文档id,会从上下文中移除</span></span><br><span class="line"><span class="attr">第五步，如果需要下一页的数据，不需要重新查询，而是直接去ES的上下文中继续拿后续内容，循环第四步和第五步,直到把上下文的内容拿空为止</span></span><br><span class="line"><span class="comment">#  scroll查询方式,不适合做实时查询，因为他去ES上下文拿不数据,不像form+size每次都要重新查询拿出某一页需要的内容</span></span><br></pre></td></tr></table></figure><p><strong>restful风格–深分页scroll查询</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#scroll=1m,表示文档id在ES上下文中会保存一分钟,如果一分钟内没有任何操作,就会清除掉</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search?scroll=1m</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"query"</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"match_all"</span>: <span class="string">&#123;&#125;#查询全部</span></span><br><span class="line">  <span class="meta">&#125;,</span><span class="string"></span></span><br><span class="line">  <span class="meta">"size"</span>: <span class="string">2,#第一页查询2条数据</span></span><br><span class="line">  <span class="meta">"sort"</span>: <span class="string">[#手动指定排序方式</span></span><br><span class="line">    <span class="attr">&#123;</span></span><br><span class="line">      <span class="meta">"fee"</span>: <span class="string">&#123;</span></span><br><span class="line">        <span class="meta">"order"</span>: <span class="string">"desc"#倒序</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#根据scroll 查询下一页数据</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">_search/scroll</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"> <span class="meta">"scroll_id"</span>:<span class="string">"根据第一查询得到的scroll_id去指定",</span></span><br><span class="line"><span class="comment">#重新指定scroll上下文再保存一分钟</span></span><br><span class="line"><span class="meta">"scroll"</span>:<span class="string">"1m"</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除scroll在ES上下文中的数据</span></span><br><span class="line"><span class="attr">DELETE</span></span><br><span class="line"><span class="attr">_search/scroll/scroll_id</span></span><br></pre></td></tr></table></figure><p><strong>Java–深分页scroll查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    RestHighLevelClient client =  EsClient.getClient();</span><br><span class="line">    String index = <span class="string">"sms-logs-index"</span>;</span><br><span class="line">    String type=<span class="string">"sms-logs-type"</span>;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定scroll信息</span></span><br><span class="line">   request.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));</span><br><span class="line">    <span class="comment">//3.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.size(<span class="number">4</span>);<span class="comment">//每次查4条数据</span></span><br><span class="line">    builder.sort(<span class="string">"fee"</span>,SortOrder.DESC);<span class="comment">//指定排序</span></span><br><span class="line">    builder.query(QueryBuilders.matchAllQuery());</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//4.获取返回结果(1)scrollId;(2)source</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    String scrollId = response.getScrollId();</span><br><span class="line">    System.out.println(<span class="string">"-------------第一页数据---------------------"</span>);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : response.getHits().getHits()) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后面的流程是为了查询下一页服务,所以应该是一个循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">        <span class="comment">//5.创建一个SearchScrollRequest,指定scrollId</span></span><br><span class="line">        SearchScrollRequest scrollRequest = <span class="keyword">new</span> SearchScrollRequest(scrollId);</span><br><span class="line">        <span class="comment">//6.指定scrolleId的生成时间</span></span><br><span class="line">scrollRequest.scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>));</span><br><span class="line">        <span class="comment">//7.执行查询获取返回结果</span></span><br><span class="line"> SearchResponse scrollResp = client.scroll(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//8.判断是否查询到了数据</span></span><br><span class="line">        SearchHit[] hits = scrollResp.getHits().getHits();</span><br><span class="line"><span class="keyword">if</span>(!=<span class="keyword">null</span> &amp;&amp; hits().length &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"-------------下一页数据---------------------"</span>);</span><br><span class="line">                <span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">                    System.out.println(hit.getSourceAsMap());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">               <span class="comment">//9.判断没有查询到数据---退出循环</span></span><br><span class="line">                System.out.println(<span class="string">"-------------结束---------------------"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在内容读取完之后,也就是退出循环之后,scrollId就没必要再保存在ES上下文中一分钟了</span></span><br><span class="line">        <span class="comment">//10.创建ClearScrollRequest并指定scrollId</span></span><br><span class="line">        ClearScrollRequest clearScrollRequest = <span class="keyword">new</span> ClearScrollRequest();</span><br><span class="line">        <span class="comment">//11.指定scrollId</span></span><br><span class="line">clearScrollRequest.addScrollId(scrollId);</span><br><span class="line">        <span class="comment">//12.清除在内存中的scrollId</span></span><br><span class="line">    ClearScrollResponse clearScrollResponse = client.clearScroll(clearScrollRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//13.输出结果</span></span><br><span class="line">    System.out.println(clearScrollResponse.isSucceeded());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="delete-by-query"><a href="#delete-by-query" class="headerlink" title="delete-by-query"></a>delete-by-query</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">根据term,match等查询方式去删除大量的文档</span></span><br><span class="line"><span class="attr">Ps</span>:<span class="string">如果你需要删除的内容是index下的大部分数据,不推荐使用delete-by-query一条一条删,建议创建一个新的索引,将要保留的内容添加到全新的索引</span></span><br></pre></td></tr></table></figure><p><strong>restful风格–delete-by-query</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_delete_by_query</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"query"</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"range"</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">"fee"</span>: <span class="string">&#123;#将费用小于4的数据查询出来进行删除</span></span><br><span class="line">      <span class="meta">"lt"</span> : <span class="string">4</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>Java–delete-by-query</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteByQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建DeleteByQueryRequest</span></span><br><span class="line">    DeleteByQueryRequest request = <span class="keyword">new</span> DeleteByQueryRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定检索条件</span></span><br><span class="line">    request.setQuery(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).lt(<span class="number">4</span>));</span><br><span class="line">    <span class="comment">//3.client执行删除操作</span></span><br><span class="line">    BulkByScrollResponse response = client.deleteByQuery(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    System.out.println(response.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;深分页Scroll&quot;&gt;&lt;a href=&quot;#深分页Scroll&quot; class=&quot;headerlink&quot; title=&quot;深分页Scroll&quot;&gt;&lt;/a&gt;深分页Scroll&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;深分页scroll查询&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ES其他各种查询</title>
    <link href="https://agonywy.github.io/2020/06/19/%E5%85%B6%E4%BB%96%E5%90%84%E7%A7%8D%E6%9F%A5%E8%AF%A2/"/>
    <id>https://agonywy.github.io/2020/06/19/%E5%85%B6%E4%BB%96%E5%90%84%E7%A7%8D%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-06-19T05:22:35.000Z</published>
    <updated>2020-08-08T06:02:48.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="id查询"><a href="#id查询" class="headerlink" title="id查询"></a>id查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">id查询</span>  <span class="string">/index/type/docId 就是文档的唯一标识</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>restful风格–id查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#id查询</span></span><br><span class="line"><span class="attr">GET</span> <span class="string">/index/type/docId</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–id查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findById</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建GetRequest</span></span><br><span class="line">    String docId = <span class="string">"123"</span>;</span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest(index,type,docId);</span><br><span class="line">    <span class="comment">//2.client执行查询操作</span></span><br><span class="line">    GetResponse resp = client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//3.输出结果</span></span><br><span class="line">    Map&lt;String, Object&gt; sourceAsMap = resp.getSourceAsMap();</span><br><span class="line">    System.out.println(sourceAsMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ids查询"><a href="#ids查询" class="headerlink" title="ids查询"></a>ids查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">根据多个id查询,类似Mysql中的where</span> <span class="string">id in (id1,id2,id3)</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–ids查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="attr">ids</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"values"</span>: <span class="string">["1","2","3"]</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–ids查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByIds</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.idsQuery().addIds(<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prefix查询"><a href="#prefix查询" class="headerlink" title="prefix查询"></a>prefix查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">前缀查询,可以通过一个关键字去指定一个Field的value的前缀,从而查询到指定的文档</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–prefix查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"prefix"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #标识某一个Filed只要是以value开头的都会被查询出来</span></span><br><span class="line">    <span class="meta">"smsContext"</span>:<span class="string">&#123;   #字段</span></span><br><span class="line">    <span class="meta">"value"</span>: <span class="string">"欢迎"#字段值前缀</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment">#和match查询的区别：match需要完全匹配,对于关键字不能分词他就查不出来</span></span><br><span class="line"><span class="comment">#但是prefix查询,对于关键字只需要前缀匹配即可,就可以查询出来</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–prefix查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prefixQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.prefixQuery(<span class="string">"smsContext"</span>,<span class="string">"欢迎"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="fuzzy查询"><a href="#fuzzy查询" class="headerlink" title="fuzzy查询"></a>fuzzy查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">模糊查询：注意和Mysql中的like是完全不同的</span></span><br><span class="line"><span class="attr">我们输入字符的大概,ES就可以根据我们输入的内容大概去匹配一下结果</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–fuzzy查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#fuzzy查询</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"fuzzy"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"companyName"</span>:<span class="string">&#123;   </span></span><br><span class="line"><span class="comment">    #很明显指定值有错别字,但是模糊查询依旧可以查询出阿里巴巴</span></span><br><span class="line">    <span class="meta">"value"</span>: <span class="string">"阿里爸巴"</span></span><br><span class="line"><span class="comment">                #另外我们还可以指定前面几个</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–fuzzy查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fuzzyQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.fuzzyQuery(<span class="string">"companyName"</span>,<span class="string">"阿里爸巴"</span>).prefixLength(<span class="number">2</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="wildcard查询"><a href="#wildcard查询" class="headerlink" title="wildcard查询"></a>wildcard查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">通配查询和Mysql中的like是一个套路,可以在查询时,在字符串中指定通配符*和占位符?</span></span><br><span class="line"><span class="meta">*通配符表示任意个字符</span> <span class="string">?占位符只表示一个字符</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–wildcard查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="attr">wildcard</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"companyName"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"vlaue"</span>: <span class="string">"中国*"</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–wildcard查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wildcardQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.wildcardQuery(<span class="string">"companyName"</span>,<span class="string">"中国*"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="range查询"><a href="#range查询" class="headerlink" title="range查询"></a>range查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">范围查询：只针对数值类型，对某一个字段进行大于或者小于的范围指定</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–range查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"range"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"age"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #gt大于;gte大于等于;lt小于;lte小于等于</span></span><br><span class="line">    <span class="meta">"gte"</span>: <span class="string">"10",</span></span><br><span class="line">    <span class="meta">"lte"</span>: <span class="string">"20"</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–range查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rangeQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.rangeQuery(<span class="string">"age"</span>).lt(<span class="number">20</span>).gt(<span class="number">10</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="regexp查询"><a href="#regexp查询" class="headerlink" title="regexp查询"></a>regexp查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">正则查询：通过编写的正则表达式去匹配内容</span></span><br><span class="line"><span class="attr">Ps</span>:<span class="string">prefix,fuzzy,wildcard,regexp查询效率相对比较低</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–regexp查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"regexp"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #使用正则表达式去查询</span></span><br><span class="line">    <span class="meta">"telephone"</span>: <span class="string">"187[0-9]&#123;8&#125;"</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–regexp查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regexpQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    builder.query(QueryBuilders.regexpQuery(<span class="string">"telephone"</span>,<span class="string">"187[0-9]&#123;8&#125;"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;id查询&quot;&gt;&lt;a href=&quot;#id查询&quot; class=&quot;headerlink&quot; title=&quot;id查询&quot;&gt;&lt;/a&gt;id查询&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;id查询&lt;/span&gt;  &lt;span class=&quot;string&quot;&gt;/index/type/docId 就是文档的唯一标识&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper选举&amp;监听</title>
    <link href="https://agonywy.github.io/2020/06/17/zookeeper%E9%80%89%E4%B8%BE%E4%B8%8E%E7%9B%91%E5%90%AC/"/>
    <id>https://agonywy.github.io/2020/06/17/zookeeper%E9%80%89%E4%B8%BE%E4%B8%8E%E7%9B%91%E5%90%AC/</id>
    <published>2020-06-17T04:12:35.000Z</published>
    <updated>2020-08-08T11:47:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h4><p>1）<strong>半数机制</strong>：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。</p><a id="more"></a><p>2）Zookeeper虽然在配置文件中并没有指定Master和Slave。但是，Zookeeper工作时，是有一个节点为Leader，其他则为Follower，Leader是通过内部的选举机制临时产生的。</p><p>3）以一个简单的例子来说明整个选举的过程。</p><p>假设有五台服务器组成的Zookeeper集群，它们的id从1-5，同时它们都是最新启动的，也就是没有历史数据，在存放数据量这一点上，都是一样的。假设这些服务器依序启动，来看看会发生什么，如图5-8所示。</p><p><strong>Zookeeper的选举机制</strong></p><p>（1）服务器1启动，此时只有它一台服务器启动了，它发出去的报文没有任何响应，所以它的选举状态一直是LOOKING状态。</p><p>（2）服务器2启动，它与最开始启动的服务器1进行通信，互相交换自己的选举结果，由于两者都没有历史数据，所以id值较大的服务器2胜出，但是由于没有达到超过半数以上的服务器都同意选举它(这个例子中的半数以上是3)，所以服务器1、2还是继续保持LOOKING状态。</p><p>（3）服务器3启动，根据前面的理论分析，服务器3成为服务器1、2、3中的老大，而与上面不同的是，此时有三台服务器选举了它，所以它成为了这次选举的Leader。</p><p>（4）服务器4启动，根据前面的分析，理论上服务器4应该是服务器1、2、3、4中最大的，但是由于前面已经有半数以上的服务器选举了服务器3，所以它只能接收当小弟的命了。</p><p>（5）服务器5启动，同4一样当小弟。</p><h4 id="Stat结构体"><a href="#Stat结构体" class="headerlink" title="Stat结构体"></a>Stat结构体</h4><p>1）czxid-创建节点的事务zxid</p><p>每次修改ZooKeeper状态都会收到一个zxid形式的时间戳，也就是ZooKeeper事务ID。</p><p>事务ID是ZooKeeper中所有修改总的次序。每个修改都有唯一的zxid，如果zxid1小于zxid2，那么zxid1在zxid2之前发生。</p><p>2）ctime - znode被创建的毫秒数(从1970年开始)</p><p>3）mzxid - znode最后更新的事务zxid</p><p>4）mtime - znode最后修改的毫秒数(从1970年开始)</p><p>5）pZxid-znode最后更新的子节点zxid</p><p>6）cversion - znode子节点变化号，znode子节点修改次数</p><p>7）dataversion - znode数据变化号</p><p>8）aclVersion - znode访问控制列表的变化号</p><p>9）ephemeralOwner- 如果是临时节点，这个是znode拥有者的session id。如果不是临时节点则是0。</p><p>10）dataLength- znode的数据长度</p><p>11）numChildren - znode子节点数量</p><h4 id="监听器原理"><a href="#监听器原理" class="headerlink" title="监听器原理"></a>监听器原理</h4><ol><li>首先要有一个<code>main()</code>线程</li><li>在<code>main</code>线程中创建<code>Zookeeper</code>客户端，这时就会创建两个线程，一个负责网络连接通信（<code>connet</code>），一个负责监听（<code>listener</code>）。</li><li>通过<code>connect</code>线程将注册的监听事件发送给<code>Zookeeper</code>。</li><li>在<code>Zookeeper</code>的注册监听器列表中将注册的监听事件添加到列表中。</li><li><code>Zookeeper</code>监听到有数据或路径变化，就会将这个消息发送给<code>listener</code>线程。</li><li><code>listener</code>线程内部调用了<code>process（）</code>方法。</li></ol><p><img src="http://lizhenchao.oss-cn-shenzhen.aliyuncs.com/1539737695.png" alt="img"></p><h4 id="监听器类型"><a href="#监听器类型" class="headerlink" title="监听器类型"></a>监听器类型</h4><p>在 Zookeeper 中, 所有读的操作都可以设置监听器. (<code>getData(), getChildren(), exists()</code>).</p><p>设置监听器的时候, 有三点需要注意:</p><ol><li><p>设置一个监听器只能触发一次.</p><p>所以, 如果想一直监听的话, 需要在监听器的回调函数执行结束之后, 再次设置监听.</p></li><li><p>当事件发生的时候, 事件会发送给那个设计监听的客户端.</p><p>没有设置监听器的是不会得到事件的.</p></li><li><p>不同的监听数据是不一样的.</p></li></ol><hr><ol><li><code>exists()</code> 可以监听到这个节点的创建, 删除, 和节点存储的数据的变化</li><li><code>getData()</code> 可以监听到节点的删除,和节点存储的数据的变化</li><li><code>getChildren()</code> 可以监听到节点的删除和节点的子节点的变化(创建和删除)</li></ol><h4 id="zookeeper一致性协议"><a href="#zookeeper一致性协议" class="headerlink" title="zookeeper一致性协议"></a>zookeeper一致性协议</h4><p>zookeeper实现数据一致性的核心是ZAB协议（Zookeeper原子消息广播协议）。该协议需要做到以下几点：<br>（1）集群在半数以下节点宕机的情况下，能正常对外提供服务；<br>（2）客户端的写请求全部转交给leader来处理，leader需确保写变更能实时同步给所有follower及observer；<br>（3）leader宕机或整个集群重启时，需要确保那些已经在leader服务器上提交的事务最终被所有服务器都提交，确保丢弃那些只在leader服务器上被提出的事务，并保证集群能快速恢复到故障前的状态。<br><strong>Zab协议有两种模式</strong>， 崩溃恢复（选主+数据同步）和消息广播（事务操作）。任何时候都需要保证只有一个主进程负责进行事务操作，而如果主进程崩溃了，就需要迅速选举出一个新的主进程。主进程的选举机制与事务操作机制是紧密相关的。</p><p><strong>ZAB协议中多次用到“过半”设计策略 ，该策略是zk在A（可用性）与C（一致性）间做的取舍，也是zk具有高容错特性的本质。相较分布式事务中的2PC（二阶段提交协议）的“全量通过”，ZAB协议可用性更高（牺牲了部分一致性），能在集群半数以下服务宕机时正常对外提供服务</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;选举机制&quot;&gt;&lt;a href=&quot;#选举机制&quot; class=&quot;headerlink&quot; title=&quot;选举机制&quot;&gt;&lt;/a&gt;选举机制&lt;/h4&gt;&lt;p&gt;1）&lt;strong&gt;半数机制&lt;/strong&gt;：集群中半数以上机器存活，集群可用。所以Zookeeper适合安装奇数台服务器。&lt;/p&gt;
    
    </summary>
    
    
      <category term="zookeeper" scheme="https://Agonywy.github.io/categories/zookeeper/"/>
    
    
      <category term="zookeeper" scheme="https://Agonywy.github.io/tags/zookeeper/"/>
    
  </entry>
  
  <entry>
    <title>Java操作索引&amp;文档</title>
    <link href="https://agonywy.github.io/2020/06/17/Java%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95+%E6%96%87%E6%A1%A3/"/>
    <id>https://agonywy.github.io/2020/06/17/Java%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95+%E6%96%87%E6%A1%A3/</id>
    <published>2020-06-17T02:12:35.000Z</published>
    <updated>2020-08-08T06:06:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Java操作索引"><a href="#Java操作索引" class="headerlink" title="Java操作索引"></a>Java操作索引</h4><ul><li>导入依赖</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.elasticeSearch依赖</span><br><span class="line">2.elasticeSearch的高级API  elasticSearch-high-level-client</span><br><span class="line">3.junit用于测试</span><br><span class="line">4.Lombok 插件</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>创建测试类：连接ES</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ESClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestHighLevelClient <span class="title">getClient</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建HttpHost对象：来指定ES的ip和端口</span></span><br><span class="line">        HttpHost httpHost = <span class="keyword">new</span> HttpHost(<span class="string">"192.168.100.109"</span>,<span class="number">9200</span>);</span><br><span class="line">        <span class="comment">//创建RestClientBuilder;</span></span><br><span class="line">        RestClientBuilder clientBuilder = RestClient.builder(httpHost);</span><br><span class="line">        <span class="comment">//创建RestHighLevelClient</span></span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(clientBuilder);</span><br><span class="line">        <span class="comment">//这样就可以连接上我们的ES了,直接返回client就可以了</span></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Java创建索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo2</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client = ESClient.getClient();</span><br><span class="line">    String index = <span class="string">"person"</span>;    <span class="comment">//索引</span></span><br><span class="line">    String type = <span class="string">"man"</span>;        <span class="comment">//类型</span></span><br><span class="line"><span class="comment">//执行这个方法ES就会创建一个索引</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.准备关于索引的settings(分片,备份信息)</span></span><br><span class="line">        Settings.Builder settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"numbers_of_shards"</span>, <span class="number">3</span>)</span><br><span class="line">                .put(<span class="string">"numbers_of_replicas"</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//2.准备关于索引的结构mappings(type,属性等信息)</span></span><br><span class="line">        <span class="comment">//startObject+endObject成对出现：代表Json格式中的&#123;&#125;</span></span><br><span class="line">        XContentBuilder mappings = JsonXContent.contentBuilder()</span><br><span class="line">                .startObject()</span><br><span class="line">                    .startObject(<span class="string">"properties"</span>)</span><br><span class="line">                        .startObject(<span class="string">"name"</span>)<span class="comment">//字段名</span></span><br><span class="line">                            .field(<span class="string">"type"</span>,<span class="string">"test"</span>)<span class="comment">//字段类型</span></span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"age"</span>)<span class="comment">//字段名</span></span><br><span class="line">                            .field(<span class="string">"type"</span>,<span class="string">"integer"</span>)<span class="comment">//字段类型</span></span><br><span class="line">                        .endObject()</span><br><span class="line">                        .startObject(<span class="string">"birthday"</span>)<span class="comment">//字段名</span></span><br><span class="line">                            .field(<span class="string">"type"</span>,<span class="string">"date"</span>)<span class="comment">//字段类型</span></span><br><span class="line">                            .field(<span class="string">"foemat"</span>,<span class="string">"yyyy-MM-dd"</span>)<span class="comment">//格式化</span></span><br><span class="line">                        .endObject()</span><br><span class="line">                    .endObject()</span><br><span class="line">                .endObject();</span><br><span class="line">        <span class="comment">//3.对settings和mappings封装到一个Request对象中</span></span><br><span class="line">        CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(index)</span><br><span class="line">                .settings(settings)</span><br><span class="line">                .mapping(type.mappings);</span><br><span class="line">        <span class="comment">//4.通过client对象去连接ES并执行创建索引</span></span><br><span class="line">        CreateIndexResponse resp = </span><br><span class="line">            client.indices().create(request,RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//5.输出</span></span><br><span class="line">        System.out.println(resp.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>检查索引是否存在</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.准备request对象,业务不同request对象也不同</span></span><br><span class="line">    <span class="comment">//client.indices().XX()不同操作参数中的Request不同</span></span><br><span class="line">    GetRequest request = <span class="keyword">new</span> GetRequest();</span><br><span class="line">    <span class="comment">//指定索引</span></span><br><span class="line">    request.indices(index);</span><br><span class="line">    <span class="comment">//2.通过Client给ES发请求去操作</span></span><br><span class="line">    <span class="keyword">boolean</span> exists = client.indices().exists(request,RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//3.输出</span></span><br><span class="line">    System.out.println(exists);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除索引</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      <span class="comment">//1.准备request对象</span></span><br><span class="line">      DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest();</span><br><span class="line">      <span class="comment">//2.指定删除哪个索引</span></span><br><span class="line">      request.indices(index);</span><br><span class="line">      <span class="comment">//3.通过Client去操作删除索引</span></span><br><span class="line">AcknowledgedResponse delete =                                                    client.indices().delete(request,RequestOptions.DEFAULT);</span><br><span class="line">      <span class="comment">///3.输出</span></span><br><span class="line">      System.out.println(delete.isAcknowledged());</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Java操作文档"><a href="#Java操作文档" class="headerlink" title="Java操作文档"></a>Java操作文档</h4><ul><li>先编写一个Person类,看看我们的数据</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//id不要序列化,id不是属性 index/type/id</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//日期要格式化,ES只认识要求的格式</span></span><br><span class="line">    <span class="meta">@Jsonformat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)</span><br><span class="line">    <span class="keyword">private</span> Date    birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加文档操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.准备一个json数据,要存放到person索引中</span></span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="number">1</span>,<span class="string">"张三"</span>,<span class="number">23</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="comment">//直接序列化成一个Json串</span></span><br><span class="line">    String json = mapper.writeValueAsString(person);</span><br><span class="line">    <span class="comment">//2.准备一个request对象封装索引,类型和json数据</span></span><br><span class="line">    <span class="comment">//封装index,type,id(index/type/id就是唯一标识文档)</span></span><br><span class="line">    <span class="comment">//这种方式就是手动指定id的方式去创建文档</span></span><br><span class="line">    IndexRequest request = <span class="keyword">new</span> IndexRequest(index,type,person.getId().toString());</span><br><span class="line">    <span class="comment">//封装数据,并且指明是Json格式</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">//3.通过client对象执行操作</span></span><br><span class="line">    IndexResponse resp = client.index(request,RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//输出返回信息</span></span><br><span class="line">    System.out.println(resp.getResult().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>修改文档操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过doc的方式去修改文档,而不是对文档进行覆盖</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">       <span class="comment">//1.创建一个map去指定需要修改的内容</span></span><br><span class="line">       Map&lt;String,Object&gt; doc = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       doc.put(<span class="string">"name"</span>,<span class="string">"李四"</span>);</span><br><span class="line">       String docId = <span class="string">"111"</span>;</span><br><span class="line">       <span class="comment">//2.创建request对象封装数据,包括index,type,id,修改的内容</span></span><br><span class="line">       UpdateRequest request = <span class="keyword">new</span> UpdateRequest(index,type,docId);</span><br><span class="line">       request.doc(doc);</span><br><span class="line">       <span class="comment">//3.通过client对象执行操作</span></span><br><span class="line">       UpdateResponse resp = client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">       <span class="comment">//4.输出返回结果</span></span><br><span class="line">       System.out.println(resp.getGetResult().toString());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>删除文档操作</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.封装request对象 index/type.docId就是文档唯一标识</span></span><br><span class="line">    String docId = <span class="string">"111"</span>;</span><br><span class="line">    DeleteRequest request = <span class="keyword">new</span> DeleteRequest(index,type,docId);</span><br><span class="line">    <span class="comment">//2.client执行删除操作</span></span><br><span class="line">    DeleteResponse resp = client.delete(request,RequestOptions.DEFAULT);</span><br><span class="line">    System.out.println(resp.getResult.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java批量操作文档"><a href="#Java批量操作文档" class="headerlink" title="Java批量操作文档"></a>Java批量操作文档</h4><ul><li>批量添加</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkCreateDoc</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建多个json数据</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="number">2</span>,<span class="string">"科比"</span>,<span class="number">18</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    Person p2 = <span class="keyword">new</span> Person(<span class="number">3</span>,<span class="string">"艾弗森"</span>,<span class="number">18</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="number">4</span>,<span class="string">"加内特"</span>,<span class="number">18</span>,<span class="keyword">new</span> Date());</span><br><span class="line">    <span class="comment">//将对象序列化成Json串</span></span><br><span class="line">    ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">    String doc1 = mapper.writeValueAsString(p1);</span><br><span class="line">    String doc2 = mapper.writeValueAsString(p2);</span><br><span class="line">    String doc3 = mapper.writeValueAsString(p3);</span><br><span class="line">    <span class="comment">//2.创建request对象封装json数据</span></span><br><span class="line">    BulkRequest request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(index,type,p1.getId().toString().source(doc1, XContentType.JSON)));</span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(index,type,p1.getId().toString().source(doc2, XContentType.JSON)));</span><br><span class="line">    request.add(<span class="keyword">new</span> IndexRequest(index,type,p1.getId().toString().source(doc3, XContentType.JSON)));</span><br><span class="line">    <span class="comment">//3.用client执行批量添加操作</span></span><br><span class="line">    BulkResponse resp = client.bulk(request,RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    System.out.println(resp.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>批量删除</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulkDeleteDoc</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        <span class="comment">//1.设置要删除的文档ID</span></span><br><span class="line">        String docId1 = <span class="string">"2"</span>;</span><br><span class="line">        String docId2 = <span class="string">"3"</span>;</span><br><span class="line">        String docId3 = <span class="string">"4"</span>;</span><br><span class="line">        <span class="comment">//2.创建request对象来封装要删除的文档信息</span></span><br><span class="line">        <span class="comment">//index/type/docId就是文档的唯一标识</span></span><br><span class="line">        BulkRequest  request = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">        request.add(<span class="keyword">new</span> DeleteRequest(index,type,docId1));</span><br><span class="line">        request.add(<span class="keyword">new</span> DeleteRequest(index,type,docId2));</span><br><span class="line">        request.add(<span class="keyword">new</span> DeleteRequest(index,type,docId3));</span><br><span class="line">        <span class="comment">//3.client执行批量删除操作</span></span><br><span class="line">        BulkResponse resp = client.bulk(request,RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//4.输出结果</span></span><br><span class="line">        System.out.println(resp.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Java操作索引&quot;&gt;&lt;a href=&quot;#Java操作索引&quot; class=&quot;headerlink&quot; title=&quot;Java操作索引&quot;&gt;&lt;/a&gt;Java操作索引&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;导入依赖&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1.elasticeSearch依赖&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2.elasticeSearch的高级API  elasticSearch-high-level-client&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.junit用于测试&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4.Lombok 插件&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>term&amp;terms查询</title>
    <link href="https://agonywy.github.io/2020/06/14/term&amp;terms%E6%9F%A5%E8%AF%A2/"/>
    <id>https://agonywy.github.io/2020/06/14/term&amp;terms%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-06-14T00:12:35.000Z</published>
    <updated>2020-08-08T06:07:28.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="terms-amp-terms查询"><a href="#terms-amp-terms查询" class="headerlink" title="terms&amp;terms查询"></a>terms&amp;terms查询</h4><ul><li><strong>restful风格–term查询</strong></li></ul><a id="more"></a><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#term查询是代表完全匹配,搜索之前不会对你搜索的关键字进行分词,对你的关键字去文档分词库中匹配内容</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">"from"</span>: <span class="string">0,#其实就是Mysql中limit的两个参数用于分页的</span></span><br><span class="line"><span class="meta">"size"</span>: <span class="string">5,</span></span><br><span class="line"><span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="meta">"term"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="meta">"province"</span>:<span class="string">&#123;#查询的内容(字段)</span></span><br><span class="line"><span class="meta">"value"</span>: <span class="string">"北京"</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java代码–term查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//term查询是代表完全匹配,搜索之前不会对你搜索的关键字进行分词,对你的关键字去文档分词库中匹配内容 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line">        <span class="comment">//2.指定查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.from(<span class="number">0</span>);    <span class="comment">//指定从第几条开始查</span></span><br><span class="line">        builder.size(<span class="number">5</span>);    <span class="comment">//指定查多少条数据</span></span><br><span class="line">        builder.query(QueryBuilders.termQuery(<span class="string">"province"</span>, <span class="string">"北京"</span>));</span><br><span class="line">        <span class="comment">//3.把条件设置到request中</span></span><br><span class="line">        request.source(builder);</span><br><span class="line">        <span class="comment">//4.client执行查询操作</span></span><br><span class="line">        SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//5.获取到_source中的数据并展示</span></span><br><span class="line">        SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; map = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–terms查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#terms和term查询机制一样,都不会将指定的查询关键字进行分词,直接去分词库中进行匹配,找到相应文档内容</span></span><br><span class="line"><span class="comment">#terms是针对一个字段包含多个值的时候使用</span></span><br><span class="line"><span class="comment">#term:  where province = "北京"</span></span><br><span class="line"><span class="comment">#terms: where province = "北京" or province = "??"</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="meta">"terms"</span>:<span class="string">&#123;#terms</span></span><br><span class="line"><span class="meta">"province"</span>:<span class="string">[#字段</span></span><br><span class="line"><span class="meta">"北京",</span>   <span class="string">#值是数组,让一个字段去匹配多个值</span></span><br><span class="line"><span class="attr">"上海",</span></span><br><span class="line"><span class="attr">"西安"</span></span><br><span class="line"><span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java代码–terms查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//terms和term查询机制一样,都不会将指定的查询关键字进行分词,直接去分词库中进行匹配,找到相应文档内容</span></span><br><span class="line"><span class="comment">//terms是针对一个字段包含多个值的时候使用</span></span><br><span class="line"><span class="comment">//term:  where province = "北京"</span></span><br><span class="line"><span class="comment">//terms: where province = "北京" or province = "??" </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">termsQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一个request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line">        <span class="comment">//2.封装查询条件</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">        builder.query(QueryBuilders.termsQuery(<span class="string">"province"</span>, <span class="string">"北京"</span>, <span class="string">"上海"</span>,<span class="string">"西安"</span>));</span><br><span class="line">        <span class="comment">//3.把条件设置到request中</span></span><br><span class="line">        request.source(builder);</span><br><span class="line">        <span class="comment">//4.client执行查询操作</span></span><br><span class="line">        SearchResponse search = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//5.找到指定数据并输出_source</span></span><br><span class="line">        SearchHit[] hits = search.getHits().getHits();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">            Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">            System.out.println(sourceAsMap);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;terms-amp-terms查询&quot;&gt;&lt;a href=&quot;#terms-amp-terms查询&quot; class=&quot;headerlink&quot; title=&quot;terms&amp;amp;terms查询&quot;&gt;&lt;/a&gt;terms&amp;amp;terms查询&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;restful风格–term查询&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>ES三种聚合查询</title>
    <link href="https://agonywy.github.io/2020/06/13/ES%E4%B8%89%E7%A7%8D%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2/"/>
    <id>https://agonywy.github.io/2020/06/13/ES%E4%B8%89%E7%A7%8D%E8%81%9A%E5%90%88%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-06-13T13:42:35.000Z</published>
    <updated>2020-08-08T06:05:38.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="cardinality去重计数聚合查询"><a href="#cardinality去重计数聚合查询" class="headerlink" title="cardinality去重计数聚合查询"></a>cardinality去重计数聚合查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ES的聚合查询和Mysql的聚合查询类似,ES的聚合查询比Mysql更加强大,ES提供的统计数据的方式多种多样</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>ES聚合查询的RSTFul语法</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="comment">#aggregations:统计,不再是query了</span></span><br><span class="line">    <span class="meta">"aggs"</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">"agg"</span>:<span class="string">&#123;#给这次聚合查询起一个名字,ES推荐叫agg</span></span><br><span class="line">            <span class="meta">"agg_type"</span>:<span class="string">&#123;#ES提供好的,直接使用就行</span></span><br><span class="line">                <span class="attr">"属性"："值"</span></span><br><span class="line">            <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–去重计数聚合查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">去重计数,cardinality</span> <span class="string">先将返回的文档中的一个指定的field进行去重,将字段重复的都去掉后,再统计一共有多少条数据</span></span><br></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="comment">#aggregations:统计,不再是query了</span></span><br><span class="line">    <span class="meta">"aggs"</span>:<span class="string">&#123;</span></span><br><span class="line">        <span class="meta">"agg"</span>:<span class="string">&#123;#给这次聚合查询起一个名字,ES推荐叫agg</span></span><br><span class="line">            <span class="meta">"cardinality"</span>:<span class="string">&#123;#这次查询的类型是去重计数聚合查询</span></span><br><span class="line"><span class="comment">            #按照省字段统计：重复的都被去重了</span></span><br><span class="line">                <span class="attr">"field"："province"</span></span><br><span class="line">            <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">去重计数聚合查询</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–cardinality去重计数聚合查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cardinalityQuery</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">    <span class="comment">//1.创建SearchRequest</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定使用聚合查询方式</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//去重计数方法cardinality()</span></span><br><span class="line">    builder.aggregation(AggregationBuilders.cardinality(<span class="string">"agg"</span>).field(<span class="string">"province"</span>));</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">// 3.执行查询</span></span><br><span class="line">    SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.输出返回结果</span></span><br><span class="line">    Cardinality agg = response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">    System.out.println(agg.getValue());</span><br></pre></td></tr></table></figure><h4 id="range范围统计聚合查询"><a href="#range范围统计聚合查询" class="headerlink" title="range范围统计聚合查询"></a>range范围统计聚合查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">统计一定范围内出现的文档个数,比如针对某一个字段的值在0~100,100~200,200~300之间文档出现的个数分别是多少</span></span><br><span class="line"><span class="attr">范围统计：可以针对普通的数值,针对时间类型,针对ip类型都可以响应</span></span><br><span class="line"><span class="meta">(1)数值</span>:  <span class="string">rang    </span></span><br><span class="line"><span class="meta">(2)时间</span>:  <span class="string">date_rang     </span></span><br><span class="line"><span class="meta">(3)ip</span>:   <span class="string">ip_rang</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–range 范围聚合查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="comment">#针对数值方式的范围统计  from 带等于效果 ，to 不带等于效果</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/sms-logs-index/sms-logs-type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"aggs"</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"agg"</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">"range"</span>: <span class="string">&#123;#数值范围聚合查询</span></span><br><span class="line">        <span class="meta">"field"</span>: <span class="string">"fee",#指定字段</span></span><br><span class="line">        <span class="meta">"ranges"</span>: <span class="string">[#指定范围,to不带等号效果,form有等号效果</span></span><br><span class="line">          <span class="attr">&#123;</span></span><br><span class="line">            <span class="meta">"to"</span>: <span class="string">30#统计小于30的文档有多少</span></span><br><span class="line">          <span class="attr">&#125;,</span></span><br><span class="line">           <span class="attr">&#123;</span></span><br><span class="line">            <span class="meta">"from"</span>: <span class="string">30,#统计大于等于30且小于60之间的文档有多少</span></span><br><span class="line">            <span class="meta">"to"</span>: <span class="string">60</span></span><br><span class="line">          <span class="attr">&#125;,</span></span><br><span class="line">          <span class="attr">&#123;</span></span><br><span class="line">            <span class="meta">"from"</span>: <span class="string">60#统计大于等于60的文档有多少</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">]</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment">#时间方式统计</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"aggs"</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"agg"</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">"date_range"</span>: <span class="string">&#123;#日期范围聚合查询</span></span><br><span class="line">        <span class="meta">"field"</span>: <span class="string">"sendDate",#指定字段</span></span><br><span class="line">        <span class="meta">"format"</span>: <span class="string">"yyyy", #格式化比较年份</span></span><br><span class="line">        <span class="meta">"ranges"</span>: <span class="string">[#指定范围</span></span><br><span class="line">          <span class="attr">&#123;</span></span><br><span class="line">            <span class="meta">"to"</span>: <span class="string">"2000"#统计小于2000年的文档有多少</span></span><br><span class="line">          <span class="attr">&#125;,&#123;</span></span><br><span class="line">            <span class="meta">"from"</span>: <span class="string">"2000"#统计大于等于2000年的文档有多少</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">]</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="comment">#ip 方式 范围统计</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/sms-logs-index/sms-logs-type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"aggs"</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"agg"</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">"ip_range"</span>: <span class="string">&#123;#ip范围聚合查询</span></span><br><span class="line">        <span class="meta">"field"</span>: <span class="string">"ipAddr",#指定字段</span></span><br><span class="line">        <span class="meta">"ranges"</span>: <span class="string">[#指定范围</span></span><br><span class="line">          <span class="attr">&#123;</span></span><br><span class="line">            <span class="meta">"to"</span>: <span class="string">"127.0.0.8"#ip小于"127.0.0.8"的ip</span></span><br><span class="line">          <span class="attr">&#125;,</span></span><br><span class="line">          <span class="attr">&#123;</span></span><br><span class="line">            <span class="meta">"from"</span>: <span class="string">"127.0.0.8" #ip大于等于"127.0.0.8"的ip</span></span><br><span class="line">          <span class="attr">&#125;</span></span><br><span class="line">        <span class="attr">]</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–range 范围聚合查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggRange</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="comment">// 1.创建request</span></span><br><span class="line">       SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">       request.types(type);</span><br><span class="line">       <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">       SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">       builder.aggregation(AggregationBuilders.range(<span class="string">"agg"</span>).field(<span class="string">"fee"</span>)</span><br><span class="line">                           .addUnboundedTo(<span class="number">30</span>)<span class="comment">//小于30</span></span><br><span class="line">                           .addRange(<span class="number">30</span>,<span class="number">60</span>)<span class="comment">//大于等于30小于60</span></span><br><span class="line">                           .addUnboundedFrom(<span class="number">60</span>));<span class="comment">//大于等于60</span></span><br><span class="line">       request.source(builder);</span><br><span class="line">       <span class="comment">// 3.执行查询</span></span><br><span class="line">       SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">       <span class="comment">// 4.输出返回结果</span></span><br><span class="line">       Range agg = response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">       <span class="keyword">for</span> (Range.Bucket bucket : agg.getBuckets()) &#123;</span><br><span class="line">           String key = bucket.getKeyAsString();</span><br><span class="line">           Object from = bucket.getFrom();</span><br><span class="line">           Object to = bucket.getTo();</span><br><span class="line">           <span class="keyword">long</span> docCount = bucket.getDocCount();<span class="comment">//文档数量</span></span><br><span class="line">           System.out.println(String.format(<span class="string">"key:%s,from:%s,to:%s,docCount:%s"</span>,                                                    key,from,to,docCount));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="extended-stats统计聚合查询"><a href="#extended-stats统计聚合查询" class="headerlink" title="extended_stats统计聚合查询"></a>extended_stats统计聚合查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">他可以帮你查询指定field</span> <span class="string">的最大值,最小值,平均值,平方和...</span></span><br><span class="line"><span class="meta">使用</span> <span class="string">extended_stats</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–extended_stats统计聚合查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#统计聚合查询 extended_stats</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="meta">"aggs"</span>: <span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"agg"</span>: <span class="string">&#123;</span></span><br><span class="line">      <span class="meta">"extended_stats"</span>: <span class="string">&#123;#这次查询的类型是统计聚合查询</span></span><br><span class="line">        <span class="meta">"field"</span>: <span class="string">"fee"</span></span><br><span class="line">      <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">  <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–extended_stats统计聚合查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggExtendedStats</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.创建request</span></span><br><span class="line">        SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">        request.types(type);</span><br><span class="line">        <span class="comment">// 2. 指定使用聚合查询方式</span></span><br><span class="line">        SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//这次查询的类型是"extended_stats"统计聚合查询</span></span><br><span class="line">        builder.aggregation(AggregationBuilders.extendedStats(<span class="string">"agg"</span>).field(<span class="string">"fee"</span>));</span><br><span class="line">        request.source(builder);</span><br><span class="line">        <span class="comment">// 3.执行查询</span></span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.输出返回结果</span></span><br><span class="line">        ExtendedStats extendedStats =  response.getAggregations().get(<span class="string">"agg"</span>);</span><br><span class="line">        System.out.println(<span class="string">"最大值："</span>+extendedStats.getMaxAsString()+</span><br><span class="line">                           <span class="string">",最小值："</span>+extendedStats.getMinAsString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;cardinality去重计数聚合查询&quot;&gt;&lt;a href=&quot;#cardinality去重计数聚合查询&quot; class=&quot;headerlink&quot; title=&quot;cardinality去重计数聚合查询&quot;&gt;&lt;/a&gt;cardinality去重计数聚合查询&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ES的聚合查询和Mysql的聚合查询类似,ES的聚合查询比Mysql更加强大,ES提供的统计数据的方式多种多样&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>bool复合&amp;filter+高亮查询</title>
    <link href="https://agonywy.github.io/2020/06/13/bool%E5%A4%8D%E5%90%88+filter+%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/"/>
    <id>https://agonywy.github.io/2020/06/13/bool%E5%A4%8D%E5%90%88+filter+%E9%AB%98%E4%BA%AE%E6%9F%A5%E8%AF%A2/</id>
    <published>2020-06-13T13:42:35.000Z</published>
    <updated>2020-08-08T06:05:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="bool查询"><a href="#bool查询" class="headerlink" title="bool查询"></a>bool查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">复合过滤器,将多个查询条件按照一定的逻辑组合在一起</span></span><br><span class="line"><span class="meta">(1)must</span>:<span class="string">所有条件组合在一起,表示and的意思</span></span><br><span class="line"><span class="meta">(2)must_not</span>: <span class="string">将must_not中的条件,全部都不匹配,表示not的意思</span></span><br><span class="line"><span class="meta">(3)should</span>:<span class="string">所有条件用should 组合在一起,表示or的意思</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li><strong>restful风格–bool查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查询省份为武汉或者北京</span></span><br><span class="line"><span class="comment">#运营商不是联通</span></span><br><span class="line"><span class="comment">#smsContent中包含中国和平安</span></span><br><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="meta">"bool"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">#should</span></span><br><span class="line"><span class="meta">"should"</span>:<span class="string">[</span></span><br><span class="line"><span class="comment">#term1</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">"term"</span>:<span class="string">&#123;</span></span><br><span class="line">                        <span class="meta">"provice"</span>:<span class="string">&#123;</span></span><br><span class="line">                            <span class="meta">"value"</span>:<span class="string">"北京"</span></span><br><span class="line">                        <span class="attr">&#125;,</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;,</span></span><br><span class="line"><span class="comment">#term2</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line"><span class="meta">"term"</span>:<span class="string">&#123;</span></span><br><span class="line">                        <span class="meta">"provice"</span>:<span class="string">&#123;</span></span><br><span class="line">                            <span class="meta">"value"</span>:<span class="string">"北京"</span></span><br><span class="line">                        <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">],</span></span><br><span class="line"><span class="comment">#must_not</span></span><br><span class="line">            <span class="meta">"must_not"</span>:<span class="string">[</span></span><br><span class="line"><span class="comment">            #term</span></span><br><span class="line">                <span class="attr">&#123;</span></span><br><span class="line">                    <span class="meta">"term"</span>:<span class="string">&#123;</span></span><br><span class="line">                        <span class="meta">"operator"</span>:<span class="string">&#123;</span></span><br><span class="line">                            <span class="meta">"value"</span>: <span class="string">"2"</span></span><br><span class="line">                        <span class="attr">&#125;</span></span><br><span class="line">                    <span class="meta">&#125;</span>            <span class="string"></span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">            <span class="attr">],</span></span><br><span class="line"><span class="comment">            #must</span></span><br><span class="line">            <span class="meta">"must"</span>:<span class="string">[</span></span><br><span class="line"><span class="comment">            #match1</span></span><br><span class="line">                <span class="attr">&#123;</span></span><br><span class="line"><span class="meta">"match"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="meta">"smsContent"</span>: <span class="string">"中国"</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line">                <span class="attr">&#125;,</span></span><br><span class="line"><span class="comment">                #match2</span></span><br><span class="line">                <span class="attr">&#123;</span></span><br><span class="line">                <span class="meta">"match"</span>:<span class="string">&#123;</span></span><br><span class="line">                <span class="meta">"smsContent"</span>: <span class="string">""平安</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">            <span class="attr">]</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–bool查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">boolQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建SearchRequest</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//先构建一个bool</span></span><br><span class="line">    BoolQueryBuilder boolQueryBuilder = QueryBuilders.bollQuery();</span><br><span class="line">    <span class="comment">//查询省份为武汉或者北京</span></span><br><span class="line">    boolQueryBuilder.should(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"武汉"</span>));</span><br><span class="line">    boolQueryBuilder.should(QueryBuilders.termQuery(<span class="string">"province"</span>,<span class="string">"北京"</span>));</span><br><span class="line"><span class="comment">//运营商不是联通</span></span><br><span class="line">    boolQueryBuilder.mustNot(QueryBuilders.termQuery(<span class="string">"operatorId"</span>,<span class="number">2</span>));</span><br><span class="line"><span class="comment">//smsContent中包含中国和平安</span></span><br><span class="line">    boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"中国"</span>));</span><br><span class="line">    boolQueryBuilder.must(QueryBuilders.matchQuery(<span class="string">"smsContent"</span>,<span class="string">"平安"</span>));</span><br><span class="line">    <span class="comment">//将bollBuilder交给builder封装</span></span><br><span class="line">    builder.query(bollBuilder);</span><br><span class="line">    <span class="comment">//将builder交给request封装</span></span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boosting查询"><a href="#boosting查询" class="headerlink" title="boosting查询"></a>boosting查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">boosting</span> <span class="string">查询可以帮助我们去影响查询后的score分数(用于排序看谁优先展示)</span></span><br><span class="line">   <span class="meta">(1)positive</span>:<span class="string">只有匹配上positive查询的内容,才会被放到返回的结果集中.</span></span><br><span class="line">   <span class="meta">(2)negative</span>: <span class="string">如果匹配上了positive也匹配上了negative,就可以降低这样的文档score.</span></span><br><span class="line">   <span class="meta">(3)negative_boost</span>:<span class="string">指定系数,必须小于1,score会乘以这个系数</span></span><br><span class="line"><span class="meta">关于查询时,分数是如何计算的：主要影响的几个地方</span>:<span class="string"></span></span><br><span class="line"><span class="attr">(1)搜索的关键字在文档中出现的频次越高,分数越高.</span></span><br><span class="line"><span class="attr">(2)指定的文档内容越短,分数越高.</span></span><br><span class="line"><span class="attr">(3)我们在搜索时,指定的关键字也会被分词,这些被分词的内容,被分词库匹配的个数越多,分数就越高.</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–boosting查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="attr">boosting</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #指定查询结果集的条件</span></span><br><span class="line">    <span class="meta">"positive"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="attr">"match"&#123;</span></span><br><span class="line">    <span class="meta">"name"</span>:<span class="string">"科比"</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line"><span class="comment">    #如果匹配,score就会乘上指定系数,score就减少了</span></span><br><span class="line">    <span class="meta">"negative"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"match"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"name"</span>:<span class="string">"艾弗森"</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line"><span class="comment">    #指定系数</span></span><br><span class="line">    <span class="meta">"negative_boost"</span>: <span class="string">0.5</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–boosting查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BoostingQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    BoostingQueryBuilder boost = QueryBuilders.boostingQuery(</span><br><span class="line">    QueryBuilders.match(<span class="string">"name"</span>,<span class="string">"科比"</span>),</span><br><span class="line">        QueryBuilders.match(<span class="string">"name"</span>,<span class="string">"艾弗森"</span>)</span><br><span class="line">    ).negativeBoost(<span class="number">0.5f</span>);</span><br><span class="line">  <span class="comment">//将boost交给builder封装</span></span><br><span class="line">    builder.query(boost);</span><br><span class="line">    <span class="comment">//将builder交给request封装</span></span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="filter查询"><a href="#filter查询" class="headerlink" title="filter查询"></a>filter查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">query查询</span>:<span class="string">根据你的查询条件,去计算文档的匹配度得到一个分数,并且根据分数进行排序,而且query查询时不会做缓存的</span></span><br><span class="line"><span class="meta">filter查询</span>:<span class="string">根据你的查询条件去查询文档,但是不会去计算分数,而且filter会对经常被过滤的数据进行缓存</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–filter查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #bool:方便我们在filter中写多个过滤的条件</span></span><br><span class="line">    <span class="meta">"bool"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"filter"</span>:<span class="string">[</span></span><br><span class="line">                <span class="attr">&#123;</span></span><br><span class="line"><span class="comment">                #基于term的方式帮我过滤出叫腾讯的公司</span></span><br><span class="line">                    <span class="meta">"term"</span>:<span class="string">&#123;</span></span><br><span class="line">                        <span class="meta">"companyName"</span>:<span class="string">"腾讯"</span></span><br><span class="line">                    <span class="meta">&#125;</span><span class="string"></span></span><br><span class="line">                <span class="attr">&#125;,</span></span><br><span class="line"><span class="comment">                #基于range的方式帮我过滤费用</span></span><br><span class="line">                <span class="attr">&#123;</span></span><br><span class="line">                    <span class="meta">"range"</span>:<span class="string">&#123;</span></span><br><span class="line">                        <span class="meta">"fee"</span>:<span class="string">&#123;</span></span><br><span class="line">                            <span class="meta">"lte"</span>: <span class="string">20</span></span><br><span class="line">                        <span class="attr">&#125;</span></span><br><span class="line">                    <span class="attr">&#125;</span></span><br><span class="line">                <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">]</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–filter查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    BoolQueryBuilder boolBuilder = QueryBuilders.boolQuery();</span><br><span class="line">   <span class="comment">//基于term方式filter</span></span><br><span class="line">    boolBuilder.filter(QueryBuilders.termQuery(<span class="string">"companyName"</span>,<span class="string">"腾讯"</span>));</span><br><span class="line">    <span class="comment">//基于range方式filter</span></span><br><span class="line">    boolBuilder.filter(QueryBuilders.rangeQuery(<span class="string">"fee"</span>).gt(<span class="number">20</span>));</span><br><span class="line">    builder.query(boolBuilder);</span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.输出结果</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getSourceAsMap());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="高亮查询"><a href="#高亮查询" class="headerlink" title="高亮查询"></a>高亮查询</h4><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">高亮查询就是用户输入的关键字,以一定特殊样式展示给用户,让用户知道为什么这个结果被检索出来</span></span><br><span class="line"><span class="attr">其实高亮展示的数据,本身就是文档中的一个field,单独将当前field以highlight的形式返回给用户</span></span><br><span class="line"><span class="attr">ES提供了一个highlight属性，他和query同级别。</span></span><br><span class="line"><span class="meta">(1)frament_size</span>: <span class="string">指定返回多少个字进行展示,默认是100</span></span><br><span class="line"><span class="meta">(2)pre_tags</span>: <span class="string">指定前缀标签&lt;font color="red"&gt;</span></span><br><span class="line"><span class="meta">(3)post_tags</span>:<span class="string">指定后缀标签 &lt;/font&gt;</span></span><br><span class="line"><span class="meta">(4)fields</span>:<span class="string">指定哪些字段以高亮方式返回</span></span><br></pre></td></tr></table></figure><ul><li><strong>restful风格–高亮查询</strong></li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">POST</span> <span class="string">/index/type/_search</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">    <span class="meta">"query"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"match"</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"companyName"</span>:<span class="string">"美团"</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line">    <span class="attr">&#125;,</span></span><br><span class="line">    <span class="meta">"highlight"</span>:<span class="string">&#123;</span></span><br><span class="line"><span class="comment">    #指定哪些字段你要高亮显示</span></span><br><span class="line">    <span class="attr">fileds</span>:<span class="string">&#123;</span></span><br><span class="line">    <span class="meta">"companyName"</span>:<span class="string">&#123;&#125;</span></span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="comment">    #指定返回多少个字进行展示,前缀,后缀</span></span><br><span class="line">    <span class="meta">"frame_size"</span>: <span class="string">5,</span></span><br><span class="line">    <span class="meta">"pre_tags"</span>:  <span class="string">"&lt;font color="red"&gt;",</span></span><br><span class="line">    <span class="meta">"post_tags"</span>: <span class="string">"&lt;/font&gt;"</span></span><br><span class="line">    </span><br><span class="line">    <span class="attr">&#125;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Java–高亮查询</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">highlightQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.创建request</span></span><br><span class="line">    SearchRequest request = <span class="keyword">new</span> SearchRequest(index);</span><br><span class="line">    request.types(type);</span><br><span class="line">    <span class="comment">//2.指定查询条件(高亮)</span></span><br><span class="line">    SearchSourceBuilder builder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    <span class="comment">//2.1查询条件</span></span><br><span class="line">    builder.query(QueryBuilders.matchQuery(<span class="string">"companyName"</span>,<span class="string">"美团"</span>));</span><br><span class="line">    <span class="comment">//2.2高亮：需要单独new一个HighlightBuilder</span></span><br><span class="line">    HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    highlightBuilder.field(<span class="string">"companyName"</span>,<span class="number">10</span>)</span><br><span class="line">                    .preTags(<span class="string">"&lt;font color='red'&gt;"</span>)</span><br><span class="line">                    .postTags(<span class="string">"&lt;/font&gt;"</span>);</span><br><span class="line">    <span class="comment">//highlightBuilder放入builder封装</span></span><br><span class="line">    builder.highlighter(highlightBuilder);</span><br><span class="line">    <span class="comment">//builder放入request封装</span></span><br><span class="line">    request.source(builder);</span><br><span class="line">    <span class="comment">//3.client执行查询操作</span></span><br><span class="line">    SearchResponse resp = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//4.获取高亮数据输出</span></span><br><span class="line">    SearchHit[] hits = resp.getHits().getHits();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">        System.out.println(hit.getHighlightFields.get(<span class="string">"companyName"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;bool查询&quot;&gt;&lt;a href=&quot;#bool查询&quot; class=&quot;headerlink&quot; title=&quot;bool查询&quot;&gt;&lt;/a&gt;bool查询&lt;/h4&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;复合过滤器,将多个查询条件按照一定的逻辑组合在一起&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;(1)must&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;所有条件组合在一起,表示and的意思&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;(2)must_not&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;将must_not中的条件,全部都不匹配,表示not的意思&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;(3)should&lt;/span&gt;:&lt;span class=&quot;string&quot;&gt;所有条件用should 组合在一起,表示or的意思&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>循环依赖与声明周期</title>
    <link href="https://agonywy.github.io/2020/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>https://agonywy.github.io/2020/06/13/%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2020-06-13T13:42:35.000Z</published>
    <updated>2020-08-08T06:01:34.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="spring中的循环依赖以及解决方式"><a href="#spring中的循环依赖以及解决方式" class="headerlink" title="spring中的循环依赖以及解决方式"></a>spring中的循环依赖以及解决方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring中的循环依赖中总共涉及了三个Map</span><br><span class="line">第一个是singletonObjects(一级缓存),就是我们说的单例池,就是一个ConcurrentHashMap</span><br><span class="line">第二个是singletonFactories(二级缓存),Spring不会直接创建bean,而是把创建bean封装成factory保存在singletonFactories中</span><br><span class="line">这个bean就放在这个beanFactory对象中,可以把这个bean返回,放在工厂里面的好处就是我们可以对bean扩展,做代理之类的，对bean进一步改造.</span><br><span class="line">二级缓存其实就是一个Map集合</span><br><span class="line">第三个是earlySingletonObjects(三级缓存),early指的是new出来但是还没有注入参数的Java对象,earlySingletonObjects管理的就是这种bean</span><br><span class="line">SingletonFactores ,三级缓存也是一个Map集合</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="springBean初始化回调"><a href="#springBean初始化回调" class="headerlink" title="springBean初始化回调"></a>springBean初始化回调</h4><p>(bean初始化的过程)：new—-&gt;populateBean注入——&gt;执行初始化回调方法——&gt;AOP((applyBeanPostProcessorsAfterInitialization()))——–&gt;put单例池中<br><strong>初始化回调有三种方式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(1)@PostConstrut 注解(2)Initialization接口，去实现方法 (3)在xml中配置init，destroy,并且是有先后顺序的</span><br><span class="line">源码中的applyBeanPostProcessorsBeforeInitialization()就是用来处理注解方式的</span><br><span class="line">invokeInitMethods()来处理接口实现与xml配置这两个方法</span><br><span class="line">AOP((applyBeanPostProcessorsAfterInitialization()):也是迭代找到合适的处理器之后,去完成代理</span><br></pre></td></tr></table></figure><h4 id="springBean的生命周期"><a href="#springBean的生命周期" class="headerlink" title="springBean的生命周期"></a>springBean的生命周期</h4><p>Object———beanDefinition———-bean </p><ol><li>Bean的定义是由BeanDefinition来描述的,比如Bean类名,构造方法参数,属性,依赖的bean,是否单例,是否懒加载等等<br>也就是说,Spring会new一个BeanDefinition的实现类对象来存储bean的相关信息</li><li>Spring会把这个BeanDefinition对象放入到一个map中，map中的key就是类名,Spring把这些类名都放在了一个List中,之后对map中的BeanDefinition进行遍历的时候,就是使用这个list来做的</li><li>在创建bean之前,可以对Bean进行扩展,创建一个类去实现BeanFactoryPostProcessor,重写postProcessorBeanFactory()方法</li><li>然后Spring在执行finishBeanFactoryInitialization()方法的时候开始实例化所有单例的非懒加载的对象</li><li>所有BeanDefinition的名字放入了List中,这时就会对list进行遍历，对每个bean都去调用getBean(beanName)方法进行实例化,<br>对beanName做一下合法验证之后开始实例化</li><li>在doGetBean()方法中有两次调用getSingleton(beanName)方法<br>bean实例化了以后其实也是放进了一个叫做singletonObjects的map里面,这个map就是单例池<br>第一次getSingleton()方法是Spring去单例池这个map中查找,看看这个bean是不是已经被实例化了,如果没有,就会返回null<br>经过一系列验证之后,他会判断当前需要的bean是不是单例,如果是单例，就会第二次调用getSingleton()方法，去createBean</li><li>在createBean()中先后9次调用了后置处理器,第一次调用后置处理器，看看postProcessBeforeInstantiation是否返回了一个对象,如果返回了直接放到容器中，如果返回的是nulll，<br>则spring创建bean的流程才会继续执行，去createBeanInstance(),在createBeanInstance()中第二次调用后置处理器推断出构造方法,然后通过反射<br>创建了一个BeanWrapper对象，打断点发现Spring推断出来的构造器返回的是null,而是通过反射拿到默认的无参构造方法去完成对象的创建，最后创建出一个bean的包裹对象BeanWrapper，<br>到此为止他还仅仅是一个Java对象，他还不是一个bean，他也没有进行属性注入,然后Spring会第三次调用后置处理器,来缓存注解信息</li><li>接下来Spring判断了一下是否允许循环依赖,默认是true，如果允许循环依赖的话，是会把对象封装成 singletonFactory，然后放到二级缓存中，<br>Spring第四次调用后置处理,把这个对象暴露出来,去做AOP操作，到此为止,属性还没有注入进来,按照流程AOP应该是在属性注入之后做的,这里加入二级缓存的意义就是<br>我们可以通过工厂对对象进行代理</li><li>然后他需要进行属性注入了,这时候执行了populateBean()，在populateBean()中完成了第五次和第六次后置处理器的调用<br>第五次调用后置处理器通过postProcessAfterInstantiation()方法判断是否进行属性注入，第六次调用后置处理器通过postProcessorPropertyValues()方法来进行属性注入<br>在populateBean中对Bean后置处理器做了一个遍历,找到合适的BeanPostProcessor去完成postProcessorPropertyValues()方法</li><li>在postProcessorPropertyValues()方法拿到元数据(meatdata)去执行inject()注入方法完成属性注入<br>如果在注入的时候需要依赖对象,就会去调用getSinglton()拿依赖bean，他会先从单例池中拿，如果拿不到，他会判断一下依赖的对象是否正在被创建,<br>如果依赖对象不是正在创建中，就会通过addSingletonFactory()方法把自己放入二级缓存中暴露出来，然后去创建依赖对象,创建完依赖对象之后,再回来进行依赖注入操作<br>如果依赖对象正在被创建,那么就会去三级缓存中拿，如果拿不到就会去二级缓存中拿到封装bean的工厂对象,从工厂对象中拿到依赖bean<br>拿到之后就把这个依赖bean给放到三级缓存中去,然后从二级缓存中删除掉，这样依赖注入就解决了，属性注入完成之后就创建了一个真正的bean,最后把bean放入到单例池中</li><li>之后初始化Spring继续执行到InitializeBean()方法,在initializeBean()方法里面会进行第七次和第八次后置处理器的调用,完成Aware的回调,<br>依次回调bean后置处理器的postProcessBeforeInitialization方法</li><li>然后如果需要进行AOP代理的话就会进行代理</li><li>最后一个完整的bean创建出来,把他放到容器当中</li></ol><h4 id="Spring策略模式："><a href="#Spring策略模式：" class="headerlink" title="Spring策略模式："></a>Spring策略模式：</h4><p>在bean的生命周期中,Spring要调用BeanPostProcessor后置处理器,这里就使用的是策略模式<br>所有的后置处理器都实现了BeanPostProcessor,但是对BeanPostProcessor每个方法都会有不同的实现<br>不同的后置处理器实现不同的功能,达到单一职责的目的</p><h4 id="为什么需要一个单例池？"><a href="#为什么需要一个单例池？" class="headerlink" title="为什么需要一个单例池？"></a>为什么需要一个单例池？</h4><p>单例对象只会实例化一次,所以需要一个单例池来缓存,以后就不需要重新创建了<br>singletonFactories:缓存的是一个工厂,主要是为了解决循环依赖</p><h4 id="为什么二级缓存中不存放实例对象，而是存放一个工厂对象？"><a href="#为什么二级缓存中不存放实例对象，而是存放一个工厂对象？" class="headerlink" title="为什么二级缓存中不存放实例对象，而是存放一个工厂对象？"></a>为什么二级缓存中不存放实例对象，而是存放一个工厂对象？</h4><p>目的就是AOP(代理),有时候依赖对象做注入的时候,我们可能需要对其进行一些改变<br>这个时候就可以在工厂中对bean进行一些操作,比如AOP之类的</p><h4 id="为什么不直接从二级缓存中拿-而是把二级缓存中的对象翻入三级缓存-然后从二级缓存中删除掉bean对象"><a href="#为什么不直接从二级缓存中拿-而是把二级缓存中的对象翻入三级缓存-然后从二级缓存中删除掉bean对象" class="headerlink" title="为什么不直接从二级缓存中拿,而是把二级缓存中的对象翻入三级缓存,然后从二级缓存中删除掉bean对象?"></a>为什么不直接从二级缓存中拿,而是把二级缓存中的对象翻入三级缓存,然后从二级缓存中删除掉bean对象?</h4><p>性能问题:这个二级缓存中存放的是封装bean的工厂对象,我们在二级缓存中可以会执行一些类似AOP这样的扩展操作,就会耗时间<br>所以如果我们每次都从二级缓存中拿,每次执行耗时操作,就会降低效率，所以我们将创建好的对象放入到三级缓存中,<br>这样就避免了在二级缓存中重复去创建对象，对系统整体来说,提高了效率</p><h4 id="Autowired与-Resource的区别"><a href="#Autowired与-Resource的区别" class="headerlink" title="@Autowired与@Resource的区别"></a>@Autowired与@Resource的区别</h4><p>(1)@Resource实现是通过CommonAnnotationBeanPostProcessor后置处理器来完成注入的<br>@Autowired的实现是通过AutowiredAnnotationBeanPostProcessor后置处理器完成注入<br>(2)@Autowired是Spring提供的注解，@Resource是Java.annotation.Resource包下面的注解<br>(3)@Autowired是按照类型注入,默认情况下他要求依赖对象必须存在,如果可以为null的话,可以i将required置为false<br>如果也想要使用名称注入的话,可以结合@Qualified注解一起使用<br>(4)@Resource注解,如果指定了名称,那么就按照名称注入,如果指定了类型,就按照类型注入,如果既没有指定名称,也没有指定类型,Spring将通过反射机制<br>使用名称自动注入</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;spring中的循环依赖以及解决方式&quot;&gt;&lt;a href=&quot;#spring中的循环依赖以及解决方式&quot; class=&quot;headerlink&quot; title=&quot;spring中的循环依赖以及解决方式&quot;&gt;&lt;/a&gt;spring中的循环依赖以及解决方式&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;spring中的循环依赖中总共涉及了三个Map&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第一个是singletonObjects(一级缓存),就是我们说的单例池,就是一个ConcurrentHashMap&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第二个是singletonFactories(二级缓存),Spring不会直接创建bean,而是把创建bean封装成factory保存在singletonFactories中&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;这个bean就放在这个beanFactory对象中,可以把这个bean返回,放在工厂里面的好处就是我们可以对bean扩展,做代理之类的，对bean进一步改造.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;二级缓存其实就是一个Map集合&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;第三个是earlySingletonObjects(三级缓存),early指的是new出来但是还没有注入参数的Java对象,earlySingletonObjects管理的就是这种bean&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;SingletonFactores ,三级缓存也是一个Map集合&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://Agonywy.github.io/categories/Spring/"/>
    
    
      <category term="spring" scheme="https://Agonywy.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>ES索引&amp;文档</title>
    <link href="https://agonywy.github.io/2020/06/08/ES%E7%B4%A2%E5%BC%95+%E6%96%87%E6%A1%A3/"/>
    <id>https://agonywy.github.io/2020/06/08/ES%E7%B4%A2%E5%BC%95+%E6%96%87%E6%A1%A3/</id>
    <published>2020-06-08T03:42:35.000Z</published>
    <updated>2020-08-08T06:08:54.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-Es基础主要概念认知"><a href="#一-Es基础主要概念认知" class="headerlink" title="(一)Es基础主要概念认知"></a>(一)Es基础主要概念认知</h4><ul><li>ES：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">是一个使用Java语言并且基于Lucene编写的搜索引擎框架,他提供了分布式的全文搜索功能，</span></span><br><span class="line"><span class="attr">还提供了一个统一的基于Restful风格的web接口,官方客户端也对多种语言都提供了API</span></span><br><span class="line"><span class="attr">ElasticSearch</span> <span class="string">中的索引更像是一种数- 据存储集合，即用于存储文档</span></span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>解释：<br>Lucene:本身就是一个搜索引擎的底层,可以理解是一个jar包封装了搜索功能,而ES又封装了Lunece<br>分布式：ES主要是为了突出他的横向扩展能力(搭建集群).<br>全文搜索:将一段词语进行分词,并且将分出来的单个词语统一的放到一个分词库中<br>在搜索时,根据指定的关键字去分词库中检索,找到匹配的内容 (倒排索引)<br>Restful风格的web接口：操作ES很简单,只需要发送一个HTTP请求,并且根据请求方式的不同和请求参数的不同<br>就可以执行相应的功能</li><li>主要概念理解</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">(1)一般意义上的索引是一种基于文档（数据）生成、建立的，用于快速定位指定文档的工具</span></span><br><span class="line"><span class="attr">(2)index就是MySQL中的数据库,type就是数据库中的表</span></span><br><span class="line"><span class="attr">(3)一个索引下可以有多个类型,就像一个数据库中可以有多个表</span></span><br><span class="line"><span class="attr">(4)一个Type下面有多个文档,doc就类似于表中的一条数据,就是我们要检索出来的内容</span></span><br><span class="line"><span class="attr">(5)文档中的filed字段,就相当于数据中的列,也就是说文档中可以包含多个filed,就像一条数据中包含多个列</span></span><br><span class="line"><span class="attr">ES6.0之后一个index下只能能创建一个type,ES7.0之后就去掉type了</span></span><br></pre></td></tr></table></figure><ul><li>ES 提供分片机制，同一个索引可以存储在不同分片（数据容器）中。</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">分片分为主分片</span> <span class="string">(primary shard) 以及从分片 (replica shard)。主分片会被尽可能平均地 (rebalance) 分配在不同的节点上</span></span><br><span class="line"><span class="meta">(例如你有2个节点,4个主分片(不考虑备份),那么每个节点会分到2个分片,后来你增加了</span> <span class="string">2 个节点,那么你这4个节点上都会有1个分片,这个过程叫 relocation,</span></span><br><span class="line"><span class="attr">ES感知后自动完成).从分片只是主分片的一个副本,它用于提供数据的冗余副本,从分片和主分片不会出现在同一个节点上（防止单点故障）,</span></span><br><span class="line"><span class="meta">默认情况下一个索引创建5个主分片，每个主分片会有一个从分片</span> <span class="string">(5 primary + 5 replica = 10 个分片),如果你只有一个节点,那么 5 个 replica</span></span><br><span class="line"><span class="meta">都无法被分配</span> <span class="string">(unassigned)，此时 cluster status 会变成 Yellow.</span></span><br></pre></td></tr></table></figure><ul><li>倒排索引：</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">(1)将你存放的数据以一定的方式进行分词,并且将分词的内容单独放到一个分词库中</span></span><br><span class="line"><span class="attr">(2)当用户查询数据时,会将用户的查询关键字进行分词,然后去分词库中匹配内容,最后得到数据的id标识</span></span><br><span class="line"><span class="attr">(3)根据id标识去真正存放数据的位置拉取到指定的数据</span></span><br></pre></td></tr></table></figure><ul><li><p>ES服务：</p><p>ES存储数据的单位是索引index,类似与Mysql服务中的数据库,ES会对索引进行分片<br>分片：比如Book索引需要存放1亿条数据,对索引分片,虽然数据都在同一个索引中,但是在逻辑上可以分片处理<br>比如id取模,偶数id的机器1处理,奇数id的机器2处理,分别处理五千万条数据,不同的机器分别去处理一部分数据,逻辑上进行不同处理,这就是分片</p></li><li><p>问题？如果每一个分片1机器挂掉了，那么这些数据是不是会丢失呢？<br>解决：ES对索引进行分片之外,还会对索引进行备份,备份的分片叫做从分片<br>机器1：ES服务1    分片1(主分片)    分片2(从分片(副本))<br>机器2：ES服务2    分片2(主分片)    分片1(从分片(副本))</p></li></ul><h3 id="二-操作ES的Restful语法："><a href="#二-操作ES的Restful语法：" class="headerlink" title="(二)操作ES的Restful语法："></a>(二)操作ES的Restful语法：</h3><ul><li>GET请求:<br><a href="http://esip:esport/index">http://esip:esport/index</a>    查询索引信息<br><a href="http://esip:esport/index/type/docId">http://esip:esport/index/type/docId</a>    查询指定的文档信息</li><li>POST请求<br><a href="http://esip:esport/index/type/_search">http://esip:esport/index/type/_search</a>    查询文档,可以在请求体中添加一个json字符串来代表查询条件<br><a href="http://esip:esport/index/type/docId/_update">http://esip:esport/index/type/docId/_update</a>    修改文档,在请求体中通过json字符串指定修改信息</li><li>PUT<br><a href="http://esip:esport/index">http://esip:esport/index</a>    创建一个索引,需要在请求体中指定索引的信息(比如分片信息,类型等)<br><a href="http://esip:esport/index/type/_mappings">http://esip:esport/index/type/_mappings</a>   代表创建索引时指定索引的文档存储的field属性信息<br>(4)Delete<br><a href="http://esip:esport/index">http://esip:esport/index</a>    删除跑路<br><a href="http://esip:esport/index/type/docId">http://esip:esport/index/type/docId</a>    删除指定的文档</li></ul><h3 id="三-索引的操作"><a href="#三-索引的操作" class="headerlink" title="(三)索引的操作"></a>(三)索引的操作</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(1)创建一个索引(暂时不指定结构),就指定一个分片</span><br><span class="line">PUT /person发送put请求创建索引名为person的索引,下面的json是我们要传递给ES的一些信息</span><br><span class="line">&#123;</span><br><span class="line">     “settings":&#123;</span><br><span class="line">       "number_of_shards":5,     (分片数）</span><br><span class="line">"number_of_replicas": 1   （备份）</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line">(2)查看索引信息：GET         /person</span><br><span class="line">(3)删除索引：     DElETE      /person</span><br></pre></td></tr></table></figure><h3 id="四-ES中常用的Field类型"><a href="#四-ES中常用的Field类型" class="headerlink" title="(四)ES中常用的Field类型"></a>(四)ES中常用的Field类型</h3><h5 id="核心字段类型"><a href="#核心字段类型" class="headerlink" title="核心字段类型"></a>核心字段类型</h5><p>(1) 字符串类型string ：被分为text和keyword两种<br>text：一般用于全文检索,将当前Field进行分词<br>keyword：当前Field不会被分词<br>(2) 数值类型integer,short,<br>long,integer,short,byte,float,double.<br>half_float:精度比float小一半<br>scaled_float:根据一个long和scaled来表达一个浮点型(举例：long-1345,scaled-100,结果3.45)<br>(3) 时间类型<br>Date:可以指定具体时间格式,有三种方式<br>年月日时分秒格式”yyyy-MM-dd HH-mm-ss”,年月日格式”yyyy-MM-dd”,毫秒值”epoch-millis”<br>(4) 布尔类型<br>(5) 二进制类型 Binary datatype<br>binary:类型暂时支持Base64编码的数据类型<br>(6) 范围类型<br>long_ranage:赋值时,无需指定具体的内容,只需要存储一个范围即可<br>float_range,integer_range,double_range,ip_range,date_range 同上<br>(7) GEO经纬度类型<br>geo_point:用来存储经纬度的<br>(8) IP类型<br>ip:可以存储ipv4或者ipv6</p><h5 id="ES创建索引并指定数据结构"><a href="#ES创建索引并指定数据结构" class="headerlink" title="ES创建索引并指定数据结构"></a>ES创建索引并指定数据结构</h5><ul><li><p>创建索引并指定数据结构</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">PUT /book&#123;</span><br><span class="line">"settings":&#123;</span><br><span class="line">"number_of_shards": 5,#分片数</span><br><span class="line">"number_of_replicas": 1,#备份数</span><br><span class="line">&#125;,</span><br><span class="line">    #数据结构</span><br><span class="line">"mappings":&#123;</span><br><span class="line">    #类型</span><br><span class="line">"novel":&#123;#类型：小说</span><br><span class="line">properties:&#123;#属性</span><br><span class="line">"name":&#123;#属性名称</span><br><span class="line">"type":"text",#属性类型,存储数据的类型</span><br><span class="line">"anayler": "ik_max_word"#使用ik分词器去分词</span><br><span class="line">    #true表示该字段可以被分词</span><br><span class="line">    #也就是说当前Filed可以作为查询条件</span><br><span class="line">"index" :true   </span><br><span class="line">#表示该字段是否要被额外存储一份</span><br><span class="line">    "store": false</span><br><span class="line">&#125;,</span><br><span class="line">"author":&#123;</span><br><span class="line">"type": "keyword"</span><br><span class="line">&#125;,</span><br><span class="line">"count":&#123;</span><br><span class="line">"type": "long"</span><br><span class="line">&#125;</span><br><span class="line">"onSale":&#123;</span><br><span class="line">"type": "date",</span><br><span class="line">                     #指定日期格式化方式</span><br><span class="line">"format": "yyyy-MM-dd HH-mm-ss" </span><br><span class="line">&#125;</span><br><span class="line">"description":&#123;</span><br><span class="line">"type": "text"</span><br><span class="line">"anayler": "ik_max_word"//使用ik分词器去分词</span><br><span class="line">"index" :true       //true表示该字段可以被分词</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="五-ES文档的操作"><a href="#五-ES文档的操作" class="headerlink" title="(五)ES文档的操作"></a>(五)ES文档的操作</h3><p>文档在ES服务中的唯一标识，<code>_index</code>，<code>_type</code>，<code>_id</code>,三个内容为符合，锁定一个文档，操作是添加还是修改，如果确定文档不存在那就是添加，反之就是修改</p><h5 id="新建文档"><a href="#新建文档" class="headerlink" title="新建文档"></a>新建文档</h5><ul><li>添加文档 ，自动生成<code>_id</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#向_index为book,_type为novel类型中添加文档</span><br><span class="line">#自动生成_id,这样就唯一标识一个文档</span><br><span class="line">POST /book/novel&#123;</span><br><span class="line">"name": "盘古",</span><br><span class="line">"author": "女娲",</span><br><span class="line">"count": "10000",</span><br><span class="line">"onSale": "2020-01-01",</span><br><span class="line">"description": "描述信息"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加文档，手动指定<code>_id</code></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#手动指定id ===&gt;&gt; PUT index/type/id</span><br><span class="line">PUT /book/novel/111&#123;</span><br><span class="line">"name": "西游记",</span><br><span class="line">"author": "罗贯中",</span><br><span class="line">"count": "10000",</span><br><span class="line">"onSale": "1888-01-01",</span><br><span class="line">"description": "描述信息"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="修改文档"><a href="#修改文档" class="headerlink" title="修改文档"></a>修改文档</h5><ul><li>覆盖式修改</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#手动指定id ===&gt;&gt; PUT index/type/id</span><br><span class="line">#唯一标识指定文档,完全覆盖内容</span><br><span class="line">PUT /book/novel/111&#123;</span><br><span class="line">"name": "红楼梦",</span><br><span class="line">"author": "曹雪芹",</span><br><span class="line">"count": "10000",</span><br><span class="line">"onSale": "1900-01-01",</span><br><span class="line">"description": "描述信息"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>基于doc修改方式</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#请求方式POST，加上_update表示修改</span><br><span class="line">POST /book/novel/111/_update&#123;</span><br><span class="line">    #这里就是基于doc方式</span><br><span class="line">"doc":&#123;</span><br><span class="line">    #通过key-value方式进行修改,其他的没修改保持原样</span><br><span class="line">    #基于doc就不会对原来的内容完全覆盖,而是针对key修改</span><br><span class="line">"key": "value"</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据id删除文档"><a href="#根据id删除文档" class="headerlink" title="根据id删除文档"></a>根据id删除文档</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#依旧是_index/_type/_id唯一标识一个文档</span><br><span class="line">DElETE /book/novel/111</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;一-Es基础主要概念认知&quot;&gt;&lt;a href=&quot;#一-Es基础主要概念认知&quot; class=&quot;headerlink&quot; title=&quot;(一)Es基础主要概念认知&quot;&gt;&lt;/a&gt;(一)Es基础主要概念认知&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;ES：&lt;/li&gt;
&lt;/ul&gt;&lt;figure class=&quot;highlight properties&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;是一个使用Java语言并且基于Lucene编写的搜索引擎框架,他提供了分布式的全文搜索功能，&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;还提供了一个统一的基于Restful风格的web接口,官方客户端也对多种语言都提供了API&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attr&quot;&gt;ElasticSearch&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;中的索引更像是一种数- 据存储集合，即用于存储文档&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/categories/ElasticSearch/"/>
    
    
      <category term="ElasticSearch" scheme="https://Agonywy.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(十一):SpringBoot与日志（框架）</title>
    <link href="https://agonywy.github.io/2020/05/20/2020-5-20-SpringBoot(%E5%8D%81%E4%B8%80)SpringBoot%E4%B8%8E%E6%97%A5%E5%BF%97%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89/"/>
    <id>https://agonywy.github.io/2020/05/20/2020-5-20-SpringBoot(%E5%8D%81%E4%B8%80)SpringBoot%E4%B8%8E%E6%97%A5%E5%BF%97%EF%BC%88%E6%A1%86%E6%9E%B6%EF%BC%89/</id>
    <published>2020-05-20T01:12:32.000Z</published>
    <updated>2020-06-14T07:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：日志框架介绍"><a href="#一：日志框架介绍" class="headerlink" title="一：日志框架介绍"></a>一：日志框架介绍</h3><p>市面上的日志框架；logback、log4j、log4j2、slf4j…</p><a id="more"></a><ul><li><table><thead><tr><th>日志的抽象层</th><th>日志实现</th></tr></thead><tbody><tr><td>SLF4j</td><td>Log4j ，JUL(java.util.logging)， Log4j2， Logback</td></tr></tbody></table></li></ul><p>左边选一个抽象层、右边来选一个实现；类似与我们经常使用的JDBC一样，选择不同的数据库驱动。</p><p>日志的抽象层：SLF4J            日志实现：LogBack</p><p>SpringBoot底层是Spring框架，Spring框架默认是用JCL(Commons logging API)</p><p><strong>SpringBoot选用SLF4J和LogBack</strong></p><h3 id="二：SLF4j使用"><a href="#二：SLF4j使用" class="headerlink" title="二：SLF4j使用"></a>二：SLF4j使用</h3><ol><li><p>如何在系统中使用SLF4j</p><p>以后开发的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法，给系统里面导入slf4j的jar和 logback的实现jar </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//log4j官网用户手册给了实例</span></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    logger.info(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过一张图来看看抽象层与不同实现需要导入哪些包</p><p>abstract logging api:抽象层        native implementation slf4j-api:具体实现    adaptation layer:适配层</p><img src="https://raw.githubusercontent.com/Agonywy/picGo/master/img/20200613224730.png" style="zoom:80%;"></li></ol><p>​      每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是  做成日志实现框架自己本身的配置文件</strong> </p><ol start="2"><li><p>遗留问题</p><p>a系统（slf4j+logback）: Spring（commons-logging）、Hibernate（jboss-logging）、MyBatis(xxxx)</p><p>统一日志记录，即使是别的框架和我一起统一使用slf4j进行输出？</p><p>这张图就体现了我们可以使用哪些jar包来替换其他框架使用的日志框架</p></li></ol><p><strong>如何让系统中所有的日志都统一到slf4j；</strong></p><ul><li><p><strong>将系统中其他日志框架先排除出去；</strong></p></li><li><p><strong>用中间包来替换原有的日志框架；</strong></p></li><li><p><strong>我们导入slf4j其他的实现</strong></p></li></ul><img src="https://raw.githubusercontent.com/Agonywy/picGo/master/img/20200613225916.png" style="zoom:80%;"><p>我们创建一个项目可以在pom.xml中右键—&gt;Diagrams—&gt;Show Dependencies查看加载了哪些依赖的示意图，ctrl滑动鼠标齿轮放大看看</p><h3 id="三：SpringBoot日志关系"><a href="#三：SpringBoot日志关系" class="headerlink" title="三：SpringBoot日志关系"></a>三：SpringBoot日志关系</h3><p>SpringBoot底层依赖关系</p><p><img src="https://raw.githubusercontent.com/Agonywy/picGo/master/img/20200614115332.png" alt></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">&lt;!--SpringBoot最基本的依赖,每一个starter都是一个场景启用器,封装不同的场景使用--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--在spring-boot-starter中又依赖了spring-boot-starter-logging,SpringBoot使用他来完成日志功能--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>总结：</p><ol><li><p>SpringBoot底层也是使用slf4j+LogBack的方式进行日志记录</p></li><li><p>SpringBoot也把其他的日志都替换成了slf4j</p></li><li><p>使用了中间替换包，偷梁换柱</p><p><img src="https://raw.githubusercontent.com/Agonywy/picGo/master/img/20200614154824.png" alt></p><p>我们以jcl-over-slf4j为例来看看他的LogFactory是怎么做的</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String UNSUPPORTED_OPERATION_IN_JCL_OVER_SLF4J =     <span class="string">"http://www.slf4j.org/codes.html#unsupported_operation_in_jcl_over_slf4j"</span>;</span><br><span class="line">    <span class="comment">//底层偷梁换柱了SLF4JLogFactory</span></span><br><span class="line">    <span class="comment">//在日志记录的时候使用的是slf4j的日志记录器</span></span><br><span class="line">    <span class="keyword">static</span> LogFactory logFactory = <span class="keyword">new</span> SLF4JLogFactory();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>如果我们引入了其他框架，一定要把这个框架的默认日志依赖移除掉 <strong>SpringBoot能自动适配所有的日志，而且底层使用slf4j+logback的方式记录日志，引入其他框架的时候，只需要把这个框架依赖的日志框架排除掉即可；</strong> </p><p>比如Spring框架用的是commons-logging，在SpringBoot中就移除了才使用 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="四：日志使用"><a href="#四：日志使用" class="headerlink" title="四：日志使用"></a>四：日志使用</h3><ol><li><p>默认配置， SpringBoot默认帮我们配置好了日志 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录器</span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//System.out.println();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//日志的级别；</span></span><br><span class="line"><span class="comment">//由低到高   trace&lt;debug&lt;info&lt;warn&lt;error</span></span><br><span class="line"><span class="comment">//可以调整输出的日志级别；日志就只会在这个级别以以后的高级别生效</span></span><br><span class="line">logger.trace(<span class="string">"这是trace日志..."</span>);</span><br><span class="line">logger.debug(<span class="string">"这是debug日志..."</span>);</span><br><span class="line"><span class="comment">//SpringBoot默认给我们使用的是info级别的，没有指定级别的就用SpringBoot默认规定的级别；root级别</span></span><br><span class="line">logger.info(<span class="string">"这是info日志..."</span>);</span><br><span class="line">logger.warn(<span class="string">"这是warn日志..."</span>);</span><br><span class="line">logger.error(<span class="string">"这是error日志..."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一：日志框架介绍&quot;&gt;&lt;a href=&quot;#一：日志框架介绍&quot; class=&quot;headerlink&quot; title=&quot;一：日志框架介绍&quot;&gt;&lt;/a&gt;一：日志框架介绍&lt;/h3&gt;&lt;p&gt;市面上的日志框架；logback、log4j、log4j2、slf4j…&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/categories/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(十):@Conditional&amp;&amp;自动配置报告</title>
    <link href="https://agonywy.github.io/2020/05/19/2020-5-19-SpringBoot(%E5%8D%81)@Conditional&amp;&amp;%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%8A%A5%E5%91%8A/"/>
    <id>https://agonywy.github.io/2020/05/19/2020-5-19-SpringBoot(%E5%8D%81)@Conditional&amp;&amp;%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E6%8A%A5%E5%91%8A/</id>
    <published>2020-05-19T13:42:35.000Z</published>
    <updated>2020-06-13T14:24:34.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一：-Conditional派生注解（Spring注解版原生的-Conditional作用）"><a href="#一：-Conditional派生注解（Spring注解版原生的-Conditional作用）" class="headerlink" title="一：@Conditional派生注解（Spring注解版原生的@Conditional作用）"></a>一：@Conditional派生注解（Spring注解版原生的@Conditional作用）</h3><a id="more"></a><p>作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效，SpringBoot把@Conditional注解扩展了很多</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用（是否满足当前的指定条件）</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是Web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是Web环境</td></tr><tr><td>@ConditionalOnJndi</td><td>JNDI存在指定项</td></tr></tbody></table><p>自动配置类必须在一定的条件下才会生效，我们怎么知道哪些自动配置类生效了？</p><p>我们可以在配置文件中通过启用debug=true属性，来让控制台打印自动配置报告，这样我们就可以很方便的知道哪些自动配置类生效了</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#开启SpringBoot的debug模式,控制台就会告诉我们哪些配置类生效了</span></span><br><span class="line"><span class="attr">debug</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">CONDITIONS EVALUATION REPORT<span class="comment">//条件评估报告</span></span><br><span class="line">============================</span><br><span class="line">Positive matches:<span class="comment">//正匹配</span></span><br><span class="line">-----------------</span><br><span class="line">   AopAutoConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnProperty</span> (spring.aop.auto=<span class="keyword">true</span>) matched (OnPropertyCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration.ClassProxyingConfiguration matched:</span><br><span class="line">      - <span class="meta">@ConditionalOnMissingClass</span> did not find unwanted <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">aspectj</span>.<span class="title">weaver</span>.<span class="title">Advice</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class">      - @<span class="title">ConditionalOnProperty</span> (<span class="title">spring</span>.<span class="title">aop</span>.<span class="title">proxy</span>-<span class="title">target</span>-<span class="title">class</span></span>=<span class="keyword">true</span>) matched (OnPropertyCondition)</span><br><span class="line">...........</span><br><span class="line"></span><br><span class="line">Negative matches:<span class="comment">//负匹配</span></span><br><span class="line">-----------------</span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required <span class="class"><span class="keyword">class</span> '<span class="title">javax</span>.<span class="title">jms</span>.<span class="title">ConnectionFactory</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line">   AopAutoConfiguration.AspectJAutoProxyingConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - <span class="meta">@ConditionalOnClass</span> did not find required <span class="class"><span class="keyword">class</span> '<span class="title">org</span>.<span class="title">aspectj</span>.<span class="title">weaver</span>.<span class="title">Advice</span>' (<span class="title">OnClassCondition</span>)</span></span><br><span class="line"><span class="class">...........</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一：-Conditional派生注解（Spring注解版原生的-Conditional作用）&quot;&gt;&lt;a href=&quot;#一：-Conditional派生注解（Spring注解版原生的-Conditional作用）&quot; class=&quot;headerlink&quot; title=&quot;一：@Conditional派生注解（Spring注解版原生的@Conditional作用）&quot;&gt;&lt;/a&gt;一：@Conditional派生注解（Spring注解版原生的@Conditional作用）&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/categories/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(九):自动配置原理</title>
    <link href="https://agonywy.github.io/2020/05/19/2020-5-19-SpringBoot(%E4%B9%9D)%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/"/>
    <id>https://agonywy.github.io/2020/05/19/2020-5-19-SpringBoot(%E4%B9%9D)%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86/</id>
    <published>2020-05-19T07:05:35.000Z</published>
    <updated>2020-06-13T10:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-自动配置原理"><a href="#一-自动配置原理" class="headerlink" title="一: 自动配置原理"></a>一: 自动配置原理</h3><ol><li><p>SpringBoot启动的时候加载主配置类，开启了自动配置功能<strong>@EnableAutoConfiguration</strong></p></li><li><p>@EnableAutoConfiguration的作用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>利用@Import(AutoConfigurationImportSelector.class)这个选择器给容器中导入了一些组件，具体导入了哪些组件呢？</p></li></ol><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;   </span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123; </span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;   </span><br><span class="line">    &#125;</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line"><span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line"><span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">//获取候选的配置</span></span><br><span class="line">List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">configurations = removeDuplicates(configurations);</span><br><span class="line">Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">checkExcludedClasses(configurations, exclusions);</span><br><span class="line">configurations.removeAll(exclusions);</span><br><span class="line">configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">getBeanClassLoader());</span><br><span class="line">Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span></span><br><span class="line">+ <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line"><span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringFactoriesLoader.loadFactoryNames(…)扫描所有jar包类路径下的META-INF/spring.factories文件，把扫描到的这些文件的内容包装成properties对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Enumeration&lt;URL&gt; urls = classLoader != <span class="keyword">null</span> ? classLoader.getResources(<span class="string">"META-INF/spring.factories"</span>) : ClassLoader.getSystemResources(<span class="string">"META-INF/spring.factories"</span>);</span><br><span class="line"><span class="comment">//把这个文件的url得到，然后把这些url每一个遍历</span></span><br><span class="line">URL url = (URL)urls.nextElement();</span><br><span class="line">UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line"><span class="comment">//最终把这些文件整成一个properties文件</span></span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line"><span class="comment">//拿到迭代器进行遍历</span></span><br><span class="line">Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(var6.hasNext()) &#123;</span><br><span class="line">                        Entry&lt;?, ?&gt; entry = (Entry)var6.next();</span><br><span class="line">    <span class="comment">//获取到factoryTypeName</span></span><br><span class="line">                        String factoryTypeName = ((String)entry.getKey()).trim();</span><br><span class="line">                        String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());</span><br><span class="line">                        <span class="keyword">int</span> var10 = var9.length;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> var11 = <span class="number">0</span>; var11 &lt; var10; ++var11) &#123;</span><br><span class="line">                            String factoryImplementationName = var9[var11];</span><br><span class="line">                            <span class="comment">//把拿到的factoryTypeName加到最终要返回的结果里面</span></span><br><span class="line">                            result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                cache.put(classLoader, result);</span><br><span class="line"><span class="comment">//这个结果就是我们要交给容器的所有组件</span></span><br><span class="line"><span class="comment">//就是从properties中获取到EnableAutoConfiguration.class类（类名）对应的值,把他们添加到容器中</span></span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>总而言之：将类路径下”META-INF/spring.factories”里面配置的所有EnableAutoConfiguration的值加入到容器中，所以我们容器中最后会有很多的组件，都在spring.factories文件中</p><p><img src="https://raw.githubusercontent.com/Agonywy/picGo/master/img/20200613155206.png" alt></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># AutoConfigureCache auto-configuration imports</span></span><br><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.core.AutoConfigureCache</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AutoConfigureDataJdbc auto-configuration imports</span></span><br><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.data.jdbc.AutoConfigureDataJdbc</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AutoConfigureDataJpa auto-configuration imports</span></span><br><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.orm.jpa.AutoConfigureDataJpa</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AutoConfigureDataLdap auto-configuration imports</span></span><br><span class="line"><span class="meta">org.springframework.boot.test.autoconfigure.data.ldap.AutoConfigureDataLdap</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration</span></span><br><span class="line"><span class="attr">............................</span></span><br><span class="line"><span class="comment"># 每一个这样的xxxAutoConfiguration类都是容器中的一个组件,都加入到容器中,用他们来做自动配置</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>每一个自动配置类进行自动配置功能</p></li><li><p>以<strong>HttpEncodingAutoConfiguration(HTTP编码自动配置)</strong>为例解释自动配置原理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示这是一个配置类，和以前写的配置文件一样，也可以给容器中添加组件</span></span><br><span class="line"><span class="meta">@Configuration</span>(proxyBeanMethods = <span class="keyword">false</span>)</span><br><span class="line"><span class="comment">//启用指定类的ConfigurationProperties功能：将配置文件中的对应的值和httpEncodingProperties绑定起来,并把httpEncodingProperties加入到IOC容器中,以后别人想用就可以用了</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个注解就是从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="comment"><span class="doctag">@ConfigurationProperties</span>(prefix = "server", ignoreUnknownFields = true)</span></span><br><span class="line"><span class="comment">public class ServerProperties &#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ServerProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//<span class="title">Spring</span>底层@<span class="title">Conditional</span>注解,根据不同的条件判断,如果满足指定的条件,整个配置类里面的配置就会生效</span></span><br><span class="line"><span class="class">//@<span class="title">ConditionalOnWebApplication</span>判断当前应用是不是<span class="title">web</span>应用,如果是,当前配置类生效</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnWebApplication</span>(<span class="title">type</span> </span>= ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="line"><span class="comment">//判断当前项目有没有CharacterEncodingFilter这个类</span></span><br><span class="line"><span class="comment">//CharacterEncodingFilter：SpringMVC中进行乱码解决的过滤器</span></span><br><span class="line"><span class="meta">@ConditionalOnClass</span>(CharacterEncodingFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">//判断配置文件中是否存在<span class="title">server</span>.<span class="title">servlet</span>.<span class="title">encoding</span>.<span class="title">enabled</span>这个配置</span></span><br><span class="line"><span class="class">//<span class="title">matchIfMissing</span> </span>= <span class="keyword">true</span>:如果不存在也认为这个判断是正确的</span><br><span class="line"><span class="meta">@ConditionalOnProperty</span>(prefix = <span class="string">"server.servlet.encoding"</span>, value = <span class="string">"enabled"</span>, matchIfMissing = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li></ol><p>根据当前不同的条件判断，决定这个配置类是否生效，一旦这个配置类生效，这个配置类就会给容器中添加各种组件，这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的</p><ol start="5"><li><p>如果生效，给容器中添加一个组件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpEncodingAutoConfiguration</span> </span>&#123;</span><br><span class="line"><span class="comment">//他已经和Spring Boot的配置文件映射了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Encoding properties;</span><br><span class="line">    <span class="comment">//只有一个有参构造器的情况下,我们这个参数的值就会从ICO容器中拿</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HttpEncodingAutoConfiguration</span><span class="params">(ServerProperties properties)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.properties = properties.getServlet().getEncoding();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span><span class="comment">//给容器中添加一个组件,这个组件的某些值需要从properties中获取,properties已经被放进了IOC容器中</span></span><br><span class="line"><span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CharacterEncodingFilter <span class="title">characterEncodingFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="comment">//SpringMVC中解决乱码使用的过滤器对象</span></span><br><span class="line">CharacterEncodingFilter filter = <span class="keyword">new</span> OrderedCharacterEncodingFilter();</span><br><span class="line"><span class="comment">//获取并设置字符集的名字,你是UTF-8编码还是什么编码？</span></span><br><span class="line">         filter.setEncoding(<span class="keyword">this</span>.properties.getCharset().name());</span><br><span class="line"></span><br><span class="line">         filter.setForceRequestEncoding(<span class="keyword">this</span>.properties.shouldForce(Encoding.Type.REQUEST));</span><br><span class="line"></span><br><span class="line">         filter.setForceResponseEncoding(<span class="keyword">this</span>.properties.shouldForce(Encoding.Type.RESPONSE));</span><br><span class="line"><span class="keyword">return</span> filter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="6"><li>所有在配置文件中能配置的属性都是在xxxProperties类中封装着，配置文件能够配置什么就可以参照某个功能对应的这个属性类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个注解就是从配置文件中获取指定的值和bean的属性进行绑定</span></span><br><span class="line"><span class="comment"><span class="doctag">@ConfigurationProperties</span>(prefix = "server", ignoreUnknownFields = true)</span></span><br><span class="line"><span class="comment">public class ServerProperties &#123;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(ServerProperties<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><ol start="7"><li><p>模拟上面的流程，我们就可以在application.properties配置文件中做相关配置了，源码中就会去给filter进行配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.servlet.encoding.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.servlet.encoding.charset</span>=<span class="string">UTF-8</span></span><br><span class="line"><span class="meta">server.servlet.encoding.force</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="二-SpringBoot精髓"><a href="#二-SpringBoot精髓" class="headerlink" title="二:SpringBoot精髓"></a>二:SpringBoot精髓</h3><ol><li>SpringBoot启动会加载大量的自动配置类</li><li>我们看我们需要的功能有没有SpringBoot默认写好的自动配置类</li><li>我们再来看这个自动配置类中到底配置了哪些组件，只要我们要用的组件有，我们就不需要再来配置了，如果没有就需要自己写一个配置类</li><li><strong>给容器中自动配置类添加组件的时候，会从properties类中的获取某些属性，我们就可以在配置文件中指定这些属性的值，也就是说他是和配置文件绑定的</strong></li></ol><p>xxxAutoConfiguration:自动配置类—–&gt;给容器中添加组件</p><p>xxxProperties:封装配置文件中相关的属性</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-自动配置原理&quot;&gt;&lt;a href=&quot;#一-自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;一: 自动配置原理&quot;&gt;&lt;/a&gt;一: 自动配置原理&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;SpringBoot启动的时候加载主配置类，开启了自动配置功能&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;@EnableAutoConfiguration的作用：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@Import&lt;/span&gt;(AutoConfigurationImportSelector&lt;span class=&quot;class&quot;&gt;.&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;利用@Import(AutoConfigurationImportSelector.class)这个选择器给容器中导入了一些组件，具体导入了哪些组件呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/categories/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/tags/Spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot(八):外部配置文件加载顺序</title>
    <link href="https://agonywy.github.io/2020/05/19/2020-5-19-SpringBoot(%E5%85%AB)%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/"/>
    <id>https://agonywy.github.io/2020/05/19/2020-5-19-SpringBoot(%E5%85%AB)%E5%A4%96%E9%83%A8%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</id>
    <published>2020-05-19T04:45:35.000Z</published>
    <updated>2020-06-13T07:10:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-配置文件加载位置优先级比较"><a href="#一-配置文件加载位置优先级比较" class="headerlink" title="一: 配置文件加载位置优先级比较"></a>一: 配置文件加载位置优先级比较</h3><p>SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级的配置会覆盖低优先级的配置，所有的配置还会形成互补配置。</p><a id="more"></a><ol><li><p>命令行参数<br>java -jar xxxxx.jar(项目包) –server.prot=8081<br>多个配置用空格隔开； –配置项=值</p></li><li><p>来自java：comp/env的NDI属性</p></li><li><p>Java系统属性（System.getProperties()）</p></li><li><p>操作系统环境变量</p></li><li><p>RandomValuePropertySource配置的random.属性值</p><p><strong>优先加载带profile的配置文件，由jar包内向jar包外进行加载，外部的会覆盖内部的配置</strong></p></li><li><p>jar包外部的application-{profile}.properties或application.yml（带spring.profile）配置文件</p></li><li><p>jar包内部的application-{profile}.properties或application.yml（带spring.profile）配置文件</p><p><strong>再来加载不带profile的配置文件</strong></p></li><li><p>jar包外部的application.properties或application.yml（不带spring.profile）配置文件</p></li><li><p>jar包内部的application.properties或application.yml（不带spring.profile）配置文件</p></li><li><p>@Configuration注解类上的@PropertySource</p></li><li><p>通过SpringApplication.setDefaultProperties指定的默认属性</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;一-配置文件加载位置优先级比较&quot;&gt;&lt;a href=&quot;#一-配置文件加载位置优先级比较&quot; class=&quot;headerlink&quot; title=&quot;一: 配置文件加载位置优先级比较&quot;&gt;&lt;/a&gt;一: 配置文件加载位置优先级比较&lt;/h3&gt;&lt;p&gt;SpringBoot也可以从以下位置加载配置；优先级从高到低；高优先级的配置会覆盖低优先级的配置，所有的配置还会形成互补配置。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/categories/Spring-boot/"/>
    
    
      <category term="Spring boot" scheme="https://Agonywy.github.io/tags/Spring-boot/"/>
    
  </entry>
  
</feed>
